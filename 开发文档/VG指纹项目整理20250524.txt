本项目旨在实现一个完整的Chromium指纹修改系统,目前要考虑开发的指纹支持mac和windwos和linux。该系统支持以下两种指纹模式：
当前源码目录：D:\chromium125.0.6422.0\src
当前IDE工作目录 D:\chromium125.0.6422.0

噪音类型指纹防护：Canvas、AudioContext等需在数据输出前添加随机微扰。
属性替换类：UserAgent、语言等需拦截API获取原始值并替换为自定义值。
底层修改类：WebRTC、地理位置等需修改底层网络接口层获取方法。

1.  **随机指纹模式**：在每次启动浏览器前，系统会自动生成一个JSON配置文件。该文件包含各项指纹的种子配置参数列表。
2.  **固定指纹环境模式**：启动浏览器时，系统会加载一个固定的JSON配置文件。此模式主要用于多账号操作场景，以确保每个账号拥有稳定一致的浏览器环境（请注意，代理IP在此模式下仍可能发生变化）。

指纹参数将通过JSON配置文件进行传递。此配置文件记录了各项指纹的种子参数。为确保配置文件的唯一性，其文件名将通过动态生成UUID（通用唯一标识符）来确保其全局唯一性。除非选择加载已有的历史指纹JSON文件，否则该配置文件会在每次浏览器启动时自动创建。

为了应用这些配置，系统将引入一个中央指纹控制器。该控制器负责统一管理，并对Chromium源码src/ui/base/l10n/l10n_util.cc中各个相关的指纹触点进行修改。

下面是具体实现方案：

当前chromium源码版本 125.0.6422.0  只是纯源码，不包含编译相关文件。
纯源码官网下载地址：https://chromium.googlesource.com/chromium/src/+archive/refs/tags/125.0.6422.0.tar.gz


浏览器指纹项目：

1、浏览器语言【 默认  自定义 】
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_language.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_language.h
文件路径(已验证): src/ui/base/l10n/l10n_util.cc
文件路径(已验证): src/net/http/http_request_headers.cc
文件路径(已验证): src/net/http/http_request_headers.h
文件路径(已验证): src/chrome/app/chrome_main_delegate.cc
文件路径(已验证): src/chrome/browser/chrome_content_browser_client.cc
文件路径(已验证): src/third_party/blink/renderer/core/html/html_html_element.cc
文件路径(已更新): src/third_party/blink/renderer/platform/text/platform_locale.cc
文件路径(已验证): src/base/i18n/rtl.cc
文件路径(已验证): src/components/language/core/browser/language_model.cc

// 修改实现细节：
// - 修改 src/third_party/blink/renderer/core/frame/navigator_language.cc 文件中获取和返回 navigator.language 和 navigator.languages 属性值的逻辑。可以拦截原始的系统语言获取函数，并返回伪造的语言字符串。
// - 修改 src/net/http/http_request_headers.cc 文件中设置 HTTP 请求头 Accept-Language 的逻辑。确保在生成请求头时，使用伪造的语言设置，而不是真实的浏览器语言。
// - 修改 src/ui/base/l10n/l10n_util.cc 中的 GetApplicationLocale 和 GetUILanguageList 等函数，确保返回一致的伪造语言设置。
// - 修改 src/third_party/blink/renderer/core/html/html_html_element.cc 中处理 <html lang=""> 属性的逻辑，防止通过默认 lang 属性泄露语言信息。
// - 修改 src/third_party/blink/renderer/modules/intl/intl_locale.cc 实现的 Intl.Locale API，这是现代指纹检测常用的获取详细语言信息的方法。
// - 确保 src/base/i18n/rtl.cc 中的文本方向判断逻辑与伪造的语言设置保持一致，避免通过文本方向间接泄露语言信息。
// - 修改 src/components/language/core/browser/language_model.cc 中的语言模型和偏好管理，确保所有语言相关行为保持一致。
// - 统一处理 Intl 对象提供的所有格式化函数（如 Intl.DateTimeFormat、Intl.NumberFormat 等），这些 API 会根据语言设置展示不同的格式。
// - 处理拼写检查功能（spellcheck API）可能暴露的语言信息，确保与伪造的语言设置一致。
// - 确保浏览器的字体回退系统与语言设置匹配，避免通过字体渲染特征泄露语言信息。
// - 实现"默认"和"自定义"选项，分别使用系统实际语言设置或允许用户指定伪造的语言代码（如 en-US、zh-CN 等）。

2、浏览器界面语言【 默认  自定义】
文件路径(已验证): src/content/public/common/content_constants.cc
文件路径(已验证): src/ui/base/l10n/l10n_util.cc
文件路径(已验证): src/chrome/browser/browser_process_impl.cc
文件路径(已验证): src/ui/base/resource/resource_bundle.cc
文件路径(已更新): src/components/language/core/browser/pref_names.h
文件路径(已验证): src/components/translate/core/browser/translate_manager.cc
文件路径(已更新): src/components/language/core/browser/language_model_manager.cc
文件路径(已验证): src/components/translate/core/browser/language_state.cc
文件路径(已验证): src/chrome/browser/ui/browser_dialogs.cc
文件路径(已验证): src/components/language/core/browser/language_prefs.cc

// 修改实现细节：
// - 主要修改点在于 src/ui/base/l10n/l10n_util.cc，这个文件包含了获取和设置 UI 语言的函数。需要修改 GetApplicationLocale()、GetUILanguageList() 等关键函数，使其返回伪造的界面语言设置。
// - 修改 src/chrome/browser/browser_process_impl.cc 中的 SetApplicationLocale() 和 GetApplicationLocale() 方法，这些方法负责设置和获取整个应用程序的区域设置。
// - 修改 src/ui/base/resource/resource_bundle.cc 中资源加载相关的函数，确保资源文件的加载路径与伪造的界面语言一致，避免通过资源加载行为泄露真实语言。
// - 修改 src/components/language/core/browser/pref_names.cc 中定义的语言相关偏好设置名称，确保偏好系统读取的语言设置与伪造值一致。
// - 修改 src/components/translate/core/browser/translate_manager.cc 中的翻译建议逻辑，确保翻译建议行为与伪造的界面语言一致，比如不对"母语"页面提供翻译。
// - 修改 src/chrome/browser/language/chrome_language_model_manager_factory.cc 中的语言模型创建逻辑，防止通过语言使用频率和偏好模型泄露真实语言。
// - 修改 src/components/translate/core/browser/language_state.cc 中的语言状态判断，确保页面语言与浏览器语言的关系逻辑符合伪造设置。
// - 修改 src/chrome/browser/ui/browser_dialogs.cc 中对话框显示逻辑，防止通过UI元素文本或布局特征泄露界面语言。
// - 确保拼写检查字典加载与伪造界面语言一致，防止通过拼写检查功能间接检测真实语言。
// - 确保右键菜单和上下文菜单中的语言特定选项（如"搜索…"、"复制"等文本）与伪造界面语言一致。
// - 处理错误页面和内部页面(如chrome://settings)的语言设置，确保这些页面使用伪造的界面语言。
// - 统一语言设置，确保 navigator.language、Accept-Language 头部和界面语言三者之间的逻辑关系合理，避免不一致导致的指纹识别。

3、时区【跟随IP匹配 自定义】
文件路径(已验证): src/content/browser/renderer_host/render_process_host_impl.cc
文件路径(已验证): src/services/device/time_zone_monitor/time_zone_monitor.cc
文件路径(已验证): src/third_party/blink/renderer/core/timing/performance.cc
文件路径(已验证): src/base/time/time.cc
文件路径(已更新): src/base/i18n/timezone.cc（时间格式化相关）
文件路径(已更新): src/third_party/blink/renderer/core/timing/performance.cc
文件路径(已更新): src/third_party/blink/renderer/core/timing/performance.h
文件路径(已更新): src/third_party/blink/renderer/core/timing/window_performance.cc
文件路径(已更新): src/third_party/blink/renderer/platform/text/locale_icu.cc
文件路径(已更新): src/base/i18n/timezone.cc
文件路径(已验证): src/base/i18n/timezone.cc
文件路径(已更新): src/base/i18n/timezone.cc

// 修改实现细节：
// - 主要修改点在 src/services/device/time_zone_monitor/time_zone_monitor.cc，这个文件负责监控系统时区变化并通知相关的组件。需要修改这里的逻辑，拦截系统时区信息，并广播伪造的时区。
// - src/content/browser/renderer_host/render_process_host_impl.cc 接收时区变化通知并传递给渲染进程，需要确保伪造信息正确传递。
// - 修改 src/third_party/blink/renderer/core/timing/date_cache.cc 中的实现，该文件负责缓存和提供日期时间信息，直接影响 JavaScript Date 对象的行为。
// - 修改 src/third_party/blink/renderer/bindings/core/v8/v8_date_constructor.cc 中的实现，确保 JavaScript Date 构造函数创建的对象使用伪造的时区信息。
// - 重点修改 Date.prototype.getTimezoneOffset() 方法的实现，这是最常用的时区检测方法，确保其返回与伪造时区一致的偏移量。
// - 修改 src/third_party/blink/renderer/modules/intl/date_time_format.cc 中的 Intl.DateTimeFormat API 实现，现代网站经常使用此 API 获取详细的时区和格式化信息。
// - 修改 src/third_party/blink/renderer/platform/wtf/time_zone.cc 中的底层时区处理逻辑，确保各层API获取到的时区信息保持一致。
// - 修改 src/base/i18n/timezone.cc 中的实现，确保从操作系统获取的时区信息被正确替换为伪造的时区。
// - 修改 src/base/i18n/time_formatting.cc 中的时间格式化逻辑，确保格式化后的时间字符串符合伪造时区的表现特征。
// - 处理夏令时相关逻辑，确保夏令时的切换行为与伪造时区一致，防止通过检测夏令时规则发现时区伪装。
// - 实现"跟随IP匹配"功能时，需要与IP地址伪装系统协同工作，根据伪造的IP地址自动选择合适的时区。这通常需要一个IP地址到时区的映射数据库。
// - 实现"自定义"功能时，允许用户指定IANA时区标识符（如"America/New_York"、"Asia/Shanghai"等）或UTC偏移量。
// - 确保所有与时间相关的API返回一致的结果，包括 performance.now()、Date.now() 等，防止通过交叉比对发现时区伪装。
// - 处理WebRTC相关的时间戳，防止通过WebRTC连接泄露真实时区。
// - src/third_party/blink/renderer/core/timing/performance.cc 中的时间相关API也需要保持一致，特别是时间测量和时间戳生成。
// - src/third_party/icu/source/i18n/timezone.cpp 是底层ICU库的时区实现，在某些情况下可能需要修改，但通常更推荐在更高层次拦截。

4、地理位置【跟随IP匹配 自定义（经度+纬度+精度） 禁用】
文件路径(已验证): src/content/browser/geolocation/geolocation_service_impl.cc
文件路径(已验证): src/third_party/blink/renderer/modules/geolocation/geolocation.cc
文件路径(已验证): src/services/device/geolocation/geolocation_provider_impl.cc
文件路径(已验证): src/components/permissions/contexts/geolocation_permission_context.cc
文件路径(已验证): src/ash/system/geolocation/geolocation_controller.cc
文件路径(已验证): src/services/device/geolocation/network_location_provider.cc
文件路径(已验证): src/services/device/geolocation/network_location_provider.h
文件路径(已验证): src/services/device/geolocation/location_arbitrator.cc
文件路径(已验证): src/services/device/geolocation/location_arbitrator.h
文件路径(已验证): src/services/device/geolocation/public_ip_address_geolocator.cc
文件路径(已验证): src/services/device/geolocation/public_ip_address_geolocator.h
文件路径(已更新): src/services/device/geolocation/geolocation_provider_impl.cc
文件路径(已验证): src/third_party/blink/renderer/modules/geolocation/geolocation_coordinates.cc
文件路径(已更新): src/third_party/blink/renderer/modules/geolocation/geolocation_coordinates.cc
文件路径(已验证): src/services/device/geolocation/wifi_data_provider_common.cc
文件路径(已验证): src/services/device/geolocation/wifi_polling_policy.cc
文件路径(已验证): src/content/browser/permissions/permission_controller_impl.cc
文件路径(已验证): src/third_party/blink/renderer/modules/permissions/permissions.cc

// 修改实现细节：
// - 核心修改点在 src/services/device/geolocation/geolocation_provider_impl.cc 和 src/content/browser/geolocation/geolocation_service_impl.cc，需要拦截系统或网络位置信息的获取，并返回伪造的经纬度、精度等信息。
// - src/third_party/blink/renderer/modules/geolocation/geolocation.cc 是 Blink 层对 navigator.geolocation API 的实现，修改这里可以确保 JS API 获取到伪造位置，但修改服务实现更彻底。
// - src/components/permissions/contexts/geolocation_permission_context.cc 处理地理位置权限，可能需要确保权限处理正常。
// - src/services/device/geolocation/network_location_provider.cc 和 src/services/device/geolocation/public_ip_address_geolocator.cc 是通过网络或 IP 获取位置的实现，可能需要修改。
// - src/services/device/geolocation/location_arbitrator.cc 负责协调多个位置信息源，修改这里可以控制最终位置信息。
// - 修改 src/third_party/blink/renderer/modules/geolocation/geolocation_coordinates.cc 和 src/third_party/blink/renderer/modules/geolocation/geolocation_position.cc，这些文件实现了 JavaScript 中的 GeolocationCoordinates 和 GeolocationPosition 对象，包含详细的位置信息，如经度、纬度、高度、精度、速度等。
// - 修改 src/third_party/blink/renderer/modules/geolocation/geolocation_controller.cc，它管理地理位置请求和更新的控制器，可以在这里拦截位置请求。
// - 修改 src/services/device/geolocation/wifi_data_provider_common.cc 和 src/services/device/geolocation/wifi_polling_policy.cc，防止通过 WiFi 扫描数据泄露真实位置。
// - 修改 src/content/browser/permissions/permission_controller_impl.cc 和 src/third_party/blink/renderer/modules/permissions/permissions.cc，处理位置权限的查询和状态变化，确保权限流程符合预期。
// - 实现"跟随IP匹配"功能时，需要与"36、IP地址"指纹项目协同工作，根据伪造的IP地址自动生成合理的地理位置数据。为此，需要维护一个IP地址到地理位置的映射数据库。
// - 实现"自定义（经度+纬度+精度）"功能时，需要允许用户精确设置所需的经纬度坐标和精度值，并确保这些值被一致地应用于所有位置相关API。
// - 实现"禁用"功能时，可以通过拒绝位置权限请求或返回错误来实现，同时确保不会泄露实际位置信息。
// - 处理高级地理位置指纹检测技术，如通过多次请求检测位置的一致性、通过速度和方向变化检测真实性、通过高度和精度值的合理性检测伪造位置。
// - 确保位置信息与其他指纹项目（如时区、语言等）保持一致，避免出现地理位置与时区不匹配等异常情况。
// - 模拟移动设备时，考虑添加合理的位置变化模式，例如沿道路移动的轨迹，而不是随机跳跃的位置点。
// - 注意处理HTML5 Geolocation API的错误回调，确保错误消息不会泄露额外信息。
// - 防范高级指纹技术，如利用位置请求的时间延迟模式来检测伪装位置的行为。

5、屏幕分辨率设置【真实、800x600 1024x600 1024x640 1024x768 1152x864 1280x720 1280x920 1280x1024 1360x768 1366x768 1400x1050 1400x900 1536x864 1600x900 1600x1050 1920x1080 1920x1200 2048x1152 2304x1140 2560x1600 2880x1800 4096x2304 5120x2880 2560x1440】
文件路径(已验证): src/third_party/blink/renderer/core/frame/screen.cc
文件路径(已验证): src/ui/display/screen.cc
文件路径(已验证): src/ui/display/display.cc
文件路径(已验证): src/ui/display/display_list.cc
文件路径(已更新): src/third_party/blink/renderer/core/css/media_values.cc
文件路径(已验证): src/third_party/blink/renderer/core/css/media_query_exp.cc
文件路径(已验证): src/third_party/blink/renderer/core/css/media_values.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/visual_viewport.cc
文件路径(已验证): src/third_party/blink/renderer/core/page/page.cc
文件路径(已验证): src/ui/display/manager/display_manager.cc
文件路径(已更新): src/ui/display/manager/display_manager.cc
文件路径(已验证): src/ui/aura/window.cc
文件路径(已验证): src/third_party/blink/renderer/core/fullscreen/fullscreen.cc
文件路径(已验证): src/third_party/blink/renderer/modules/screen_orientation/screen_orientation_controller.cc
文件路径(已更新): src/third_party/blink/renderer/core/frame/screen.cc
文件路径(已更新): src/third_party/blink/renderer/core/resize_observer/resize_observer.cc

// 修改实现细节：
// - 主要修改点在 src/ui/display/screen.cc。这个文件负责从操作系统获取真实的屏幕显示信息，包括分辨率。需要修改其中获取屏幕宽度、高度等信息的函数，拦截系统调用，并返回伪造的分辨率数值。
// - 修改 src/ui/display/display.cc 定义了显示设备的核心类和属性，包括分辨率、DPR等，可修改此处提供统一的显示信息伪造。
// - 修改 src/ui/display/display_list.cc 管理多显示器环境下的显示器列表，对于多显示器环境的指纹防护很重要。
// - 修改 src/third_party/blink/renderer/core/frame/screen.cc 在Blink层实现window.screen对象，会调用UI显示接口获取分辨率信息。
// - 修改 src/third_party/blink/renderer/core/layout/adjust_for_device_scale_factor.h 与屏幕分辨率和设备像素比相关，影响渲染逻辑。
// - 修改 src/third_party/blink/renderer/core/css/media_query_exp.cc 和 src/third_party/blink/renderer/core/css/media_values.cc 处理CSS媒体查询，现代网站通常使用@media查询来检测屏幕尺寸特性，确保媒体查询结果与伪造的分辨率一致。
// - 修改 src/third_party/blink/renderer/core/frame/visual_viewport.cc 处理视觉视口，影响移动设备和缩放状态下的显示，确保视口尺寸与屏幕分辨率保持合理比例。
// - 修改 src/third_party/blink/renderer/core/page/page.cc 页面设置，包括视口约束和初始缩放比例设置。
// - 修改 src/ui/display/manager/display_manager.cc 和 src/ui/display/manager/display_layout_manager.cc 管理多显示器环境和显示器布局，防止通过多显示器特性检测指纹。
// - 修改 src/ui/aura/window.cc 控制窗口尺寸和边界，确保窗口最大化行为与伪造分辨率一致。
// - 修改 src/third_party/blink/renderer/core/fullscreen/fullscreen.cc 处理全屏模式，确保全屏时的分辨率和行为符合伪造设置。
// - 修改 src/third_party/blink/renderer/modules/screen_orientation/screen_orientation_controller.cc 处理屏幕方向变化，确保横屏/竖屏切换时的分辨率正确转换。
// - 修改 src/third_party/blink/renderer/core/frame/window_screen_util.cc 提供屏幕相关的各种工具函数，是屏幕尺寸数据的重要来源。
// - 修改 src/third_party/blink/renderer/core/frame/resize_observer.cc 处理元素尺寸变化的观察，防止通过监测尺寸变化来检测指纹。
// - 对于所有尺寸相关的API，确保返回值之间保持合理的数学关系，例如：
//   * window.innerWidth/Height 应小于或等于 screen.availWidth/Height
//   * screen.availWidth/Height 应小于或等于 screen.width/height
//   * window.outerWidth/Height 应大于 window.innerWidth/Height
//   * 全屏时的尺寸应当符合伪造的屏幕分辨率
// - 处理现代指纹检测中的高级技术，如：
//   * 检测窗口尺寸变化响应的延迟和精度
//   * 通过Canvas/WebGL检测像素精确度
//   * 分析媒体查询触发点的精确性
//   * 检测屏幕旋转时的分辨率切换行为
// - 在浏览器标签页分离或拖拽时，保持分辨率数据的一致性。
// - 确保不同页面和iframe之间获取的屏幕信息保持一致。
// - 在不同API和事件（如resize事件）中保持分辨率数据的一致性。

6、显示缩放比例【真实】
文件路径(已验证): src/third_party/blink/renderer/core/frame/screen.cc
文件路径(已验证): src/ui/display/screen.cc
文件路径(已验证): src/ui/display/display.cc
文件路径(已验证): src/ui/display/display_list.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/local_dom_window.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc
文件路径(已验证): src/third_party/blink/renderer/core/css/media_values_dynamic.cc
文件路径(已更新): src/third_party/blink/renderer/core/css/media_values_dynamic.cc
文件路径(已验证): src/third_party/blink/renderer/core/page/chrome_client.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/visual_viewport.cc
文件路径(已验证): src/third_party/blink/renderer/platform/graphics/graphics_context.cc
文件路径(已验证): src/third_party/blink/renderer/core/resize_observer/resize_observer.cc
文件路径(已验证): src/third_party/blink/renderer/modules/screen_orientation/screen_orientation_controller.cc

// 修改实现细节：
// - 主要修改点在 src/ui/display/screen.cc。这个文件负责从操作系统获取设备像素比（Device Pixel Ratio，DPR）。需要修改获取 DPR 的相关函数，拦截系统调用，并返回伪造的缩放比例数值（例如 1.0 对应 100%，1.25 对应 125%）。
// - 修改 src/ui/display/display.cc 定义了显示设备的核心类和属性，包括分辨率、DPR等，可修改此处提供统一的显示信息伪造。
// - 修改 src/ui/display/display_list.cc 管理多显示器环境下的显示器列表，对于多显示器环境的指纹防护很重要。
// - 修改 src/third_party/blink/renderer/core/frame/screen.cc 在Blink层实现window.screen对象，会调用 ui/display/screen.cc 中的函数来获取 DPR。确保修改 ui/display/screen.cc 后，能够正确获取到伪造的值并暴露给 JavaScript。
// - 修改 src/third_party/blink/renderer/core/frame/local_dom_window.cc 实现了window对象，包括关键的devicePixelRatio属性，这是最常用的DPR检测方法。
// - 修改 src/third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc 管理全局作用域下的设备特性访问，影响worker线程中的DPR获取。
// - 修改 src/third_party/blink/renderer/core/css/media_values_dynamic.cc 处理CSS媒体查询中的resolution特性，网站常通过@media (resolution: Xdppx)来检测DPR。
// - 修改 src/third_party/blink/renderer/core/css/cssom/computed_style.cc 确保通过getComputedStyle获取的值与伪造的DPR一致。
// - 修改 src/third_party/blink/renderer/core/page/chrome_client.cc 管理浏览器界面与渲染层之间的交互，包括缩放相关事件。
// - 修改 src/third_party/blink/renderer/core/frame/visual_viewport.cc 控制视觉视口，尤其是移动设备和触控时的缩放行为。
// - 修改 src/third_party/blink/renderer/platform/graphics/graphics_context.cc 处理绘图上下文的缩放因子，确保渲染时使用一致的DPR。
// - 修改 src/third_party/blink/renderer/core/resize_observer/resize_observer.cc 观察元素尺寸变化，可能间接暴露DPR变化。
// - 修改 src/third_party/blink/renderer/modules/screen_orientation/screen_orientation_controller.cc 处理屏幕方向变化时的DPR调整。
// - 需要处理的关键DPR检测方法：
//   * window.devicePixelRatio (最常用)
//   * CSS媒体查询: @media (resolution: Xdppx)
//   * Canvas和WebGL上下文的像素密度调整
//   * matchMedia('(resolution: Xdppx)').matches
//   * 通过绘制特定元素并测量其像素尺寸的间接检测
// - 确保DPR伪装在以下场景中保持一致：
//   * 页面缩放操作前后
//   * 屏幕方向变化时
//   * 不同窗口或iframe之间
//   * 浏览器窗口大小调整时
//   * 全屏模式切换时
// - 防御高级DPR检测技术：
//   * 通过绘制特殊形状后测量像素数量的Canvas检测
//   * 通过WebGL纹理和渲染精度分析的检测
//   * 通过CSS transform缩放后的像素精确度检测
//   * 通过对比元素实际渲染尺寸与计算尺寸的差异检测
//   * 通过字体渲染中的亚像素抗锯齿特征检测
// - 确保DPR值与其他指纹特征（如屏幕分辨率、窗口尺寸）保持数学上的合理关系，避免出现矛盾值。

7、可用屏幕尺寸【建议数值小于分辨率，0为不设置】
文件路径(已验证): src/third_party/blink/renderer/core/frame/screen.cc
文件路径(已验证): src/ui/display/screen.cc
文件路径(已验证): src/ui/display/display_observer.cc
文件路径(已验证): src/ui/display/win/screen_win.cc
文件路径(已验证): src/ui/display/mac/screen_mac.mm
文件路径(已验证): src/ui/display/display_change_notifier.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/local_dom_window.cc
文件路径(已验证): src/ui/display/manager/display_manager.cc
文件路径(已更新): src/ui/display/manager/display_manager.cc
文件路径(已更新): src/third_party/blink/renderer/core/frame/local_dom_window.cc
文件路径(已验证): src/third_party/blink/renderer/core/css/media_values.cc
文件路径(已验证): src/third_party/blink/renderer/core/page/viewport_description.cc

// 修改实现细节：
// - 主要修改点在 src/ui/display/screen.cc。这个文件负责从操作系统获取可用屏幕区域的尺寸（排除任务栏、停靠窗口等）。需要修改获取可用屏幕宽度、高度等信息的函数，拦截系统调用，并返回伪造的可用屏幕尺寸数值。这些数值通常小于或等于伪造的屏幕分辨率。
// - 修改 src/third_party/blink/renderer/core/frame/screen.cc 实现了 window.screen.availWidth 和 window.screen.availHeight 属性，它们会调用 ui/display/screen.cc 中的函数来获取可用屏幕尺寸。确保修改 ui/display/screen.cc 后，能够正确获取到伪造的值并暴露给 JavaScript。
// - 修改 src/ui/display/display_observer.cc 处理显示器变化通知，确保在屏幕配置改变时保持伪造数值的一致性。
// - 修改平台相关文件（src/ui/display/win/screen_win.cc、src/ui/display/mac/screen_mac.mm）是获取真实可用屏幕区域的平台实现，需要在这些文件中拦截系统调用。
// - 修改 src/ui/display/display_change_notifier.cc 负责通知显示器配置变化，确保变化事件中也使用伪造的值。
// - 修改 src/third_party/blink/renderer/core/frame/local_dom_window.cc 处理 window 对象，可能通过其他途径（如innerWidth/innerHeight）间接泄露可用屏幕尺寸。
// - 修改 src/ui/display/manager/display_manager.cc 管理多显示器环境，影响主显示器和辅助显示器的可用区域报告。
// - 修改 src/ui/views/widget/desktop_aura/desktop_screen.cc 提供桌面窗口环境中的屏幕信息，影响可用工作区的计算。
// - 修改 src/content/browser/web_contents/web_contents_view.cc 管理网页内容视图尺寸，与可用屏幕空间相关。
// - 修改 src/third_party/blink/renderer/core/css/media_values.cc 处理CSS媒体查询，需确保媒体查询与伪造的可用屏幕尺寸一致。
// - 修改 src/third_party/blink/renderer/core/page/viewport_description.cc 处理视口配置，确保视口设置与伪造的可用区域匹配。

// - 需要确保所有与可用屏幕尺寸相关的API返回一致的数据：
//   * window.screen.availWidth/availHeight (主要接口)
//   * window.innerWidth/innerHeight (应与可用区域相关，尤其是最大化窗口时)
//   * CSS媒体查询中的宽度和高度检测
//   * 文档元素的可见区域尺寸
//   * 全屏时的可用区域

// - 防御现代指纹检测技术时需注意：
//   * 确保工作区尺寸与屏幕分辨率的差值合理（例如，一般任务栏高度在Windows上约为30-40px）
//   * 在窗口尺寸变化时，保持可用区域与窗口尺寸的合理关系
//   * 响应窗口最大化事件时，窗口尺寸应接近但不超过可用屏幕区域
//   * 不同窗口和iframe之间的一致性
//   * 确保在屏幕旋转或DPI变化时保持一致的比例关系
//   * 全屏模式切换时的逻辑一致性（全屏时通常window.innerHeight应等于screen.height）

// - 针对高级检测技术的额外保护：
//   * 通过ResizeObserver监控的窗口尺寸变化
//   * 基于元素视觉边界与viewport比例关系的间接检测
//   * 多显示器环境下主屏与副屏的可用区域逻辑关系
//   * 任务栏位置（顶部/底部/侧边）对可用区域形状的影响

8、颜色深度【0为不设置】
文件路径(已验证): src/third_party/blink/renderer/core/frame/screen.cc
文件路径(已验证): src/ui/display/screen.cc
文件路径(已验证): src/ui/display/win/display_info.cc
文件路径(已更新): src/ui/display/display.cc
文件路径(已验证): src/ui/display/display.cc
文件路径(已验证): src/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.cc
文件路径(已验证): src/gpu/config/gpu_info.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
文件路径(已更新): src/ui/gfx/color_space.cc
文件路径(已验证): src/third_party/blink/renderer/core/css/media_values.cc
文件路径(已验证): src/ui/gfx/color_space.cc

// 修改实现细节：
// - 主要修改点在 src/ui/display/screen.cc。这个文件负责从操作系统获取屏幕的颜色深度。需要修改获取颜色深度相关的函数，拦截系统调用，并返回伪造的颜色深度数值（通常是 24 或 32）。
// - 修改 src/third_party/blink/renderer/core/frame/screen.cc 实现了 window.screen.colorDepth 和 window.screen.pixelDepth 属性，它们会调用 ui/display/screen.cc 中的函数来获取颜色深度。确保修改 ui/display/screen.cc 后，能够正确获取到伪造的值并暴露给 JavaScript。
// - 修改平台特定的颜色深度获取实现，包括 src/ui/display/win/display_info.cc（Windows平台）和 src/ui/display/mac/display_info_mac.mm（macOS平台），这些文件包含获取实际颜色深度的平台特定代码。
// - 修改 src/ui/display/display.cc 中处理显示设备属性的代码，确保颜色深度与其他显示属性保持一致性。
// - 修改 src/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.cc 处理Canvas上下文的颜色深度和色彩空间，这影响Canvas指纹与颜色深度的关联。
// - 修改 src/gpu/config/gpu_info.cc 提供GPU相关信息，包括支持的颜色格式，确保与伪造的颜色深度一致。
// - 修改 src/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc 处理WebGL上下文的颜色深度设置，在WebGL中也需保持一致的颜色深度。
// - 修改 src/third_party/skia/src/core/SkColorSpace.cpp 处理底层绘图引擎的色彩空间，影响颜色表现和渲染精度。
// - 修改 src/third_party/blink/renderer/core/css/media_values.cc 处理CSS媒体查询中与颜色相关的特性（如color、color-index等），确保媒体查询结果与伪造的颜色深度一致。
// - 修改 src/ui/gfx/color_space.cc 定义颜色空间转换和处理，影响整个渲染管线中的颜色处理。

// - 需要确保颜色深度伪装在以下几方面保持一致性：
//   * 基本属性：window.screen.colorDepth 和 window.screen.pixelDepth 返回相同的伪造值
//   * Canvas上下文：创建Canvas上下文时使用的颜色深度
//   * WebGL上下文：WebGL渲染使用的颜色格式和深度
//   * CSS媒体查询：响应 @media (color: X) 和 @media (color-index: X) 的查询
//   * 系统报告：通过系统API获取的颜色空间和色彩格式信息

// - 防御现代指纹检测技术需注意：
//   * 高精度色彩区分测试：某些网站会绘制特定颜色渐变并读取像素值，检测实际支持的颜色精度
//   * 通过Canvas间接检测：创建不同位深的Canvas并比较其输出差异
//   * 通过WebGL着色器精度检测颜色处理能力
//   * HDR支持检测：通过检测高动态范围颜色支持来推断显示能力
//   * 色域检测：通过测试特定色域（如P3、sRGB等）的支持情况来识别显示器
//   * 显示器色温检测：分析渲染颜色与标准预期的微小差异

// - 伪造颜色深度时，需考虑与以下指纹项目的协调：
//   * WebGL特性掩码：确保GL参数中的颜色缓冲区深度与伪造的颜色深度一致
//   * 屏幕分辨率：高分辨率屏幕通常具有更高的颜色深度，保持合理的关联
//   * 设备像素比：高DPR设备通常支持更广的色域和更高的色深
//   * GPU信息：确保伪造的GPU信息中的颜色支持与颜色深度一致

9、最大触控点【0为不设置，移动端可设置为5】
文件路径(已验证): src/third_party/blink/renderer/core/frame/screen.cc
文件路径(已验证): src/ui/display/screen.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(已更新): src/third_party/blink/renderer/core/events/touch_event.cc
文件路径(已验证): src/content/browser/renderer_host/input/touch_emulator.cc
文件路径(已验证): src/ui/events/devices/input_device.cc
文件路径(已验证): src/third_party/blink/renderer/modules/device_orientation/device_orientation_controller.cc
文件路径(已更新): src/third_party/blink/renderer/core/events/pointer_event.cc
文件路径(已更新): src/third_party/blink/renderer/core/dom/events/event_target.cc
文件路径(已验证): src/third_party/blink/renderer/core/dom/events/event_target.cc
文件路径(已验证): src/third_party/blink/renderer/core/events/pointer_event.cc
文件路径(已验证): src/third_party/blink/renderer/core/events/touch_event.cc
文件路径(已验证): src/third_party/blink/renderer/core/page/touch_adjustment.cc

// 修改实现细节：
// - 主要修改点在 src/third_party/blink/renderer/core/frame/navigator.cc。这个文件实现了navigator对象及其属性，包括navigator.maxTouchPoints。需要修改获取最大触控点数量的函数，拦截系统调用，并返回伪造的数值。对于桌面浏览器通常是 0，移动端可以设置为 5 或其他值。
// - src/ui/display/screen.cc 提供底层屏幕信息，包括触控能力，但navigator.maxTouchPoints主要来自navigator.cc实现。
// - 修改 src/third_party/blink/renderer/core/input/touch_util.cc 处理触控事件的工具函数，确保事件处理逻辑与伪造的触控点数量一致。
// - 修改 src/content/browser/renderer_host/input/touch_emulator.cc 控制触控模拟行为，确保模拟触控事件与伪造的触控点数量匹配。
// - 修改 src/ui/events/devices/input_device.cc 定义输入设备特性，包括设备支持的最大触控点数。
// - 修改 src/third_party/blink/renderer/modules/device_orientation/device_orientation_controller.cc 与设备方向和移动传感器相关，通常与触控能力相关联。
// - 修改 src/ui/events/blink/web_input_event_builders.cc 构建输入事件，确保touch事件的创建逻辑与伪造的触控点数量一致。
// - 修改 src/third_party/blink/renderer/platform/runtime_enabled_features.cc 控制功能标志，影响触控相关API的可用性。
// - 修改 src/third_party/blink/renderer/core/dom/events/event_target.cc 处理事件目标，确保触控事件分发逻辑与伪造设置一致。
// - 修改 src/third_party/blink/renderer/core/events/pointer_event.cc 和 src/third_party/blink/renderer/core/events/touch_event.cc 实现指针和触控事件，需确保与伪造的触控能力一致。
// - 修改 src/third_party/blink/renderer/core/page/touch_adjustment.cc 处理触控点的调整逻辑，确保与伪造的触控特性一致。

// - 全面防护需要考虑多种触控能力检测方法：
//   * navigator.maxTouchPoints - 直接检测（最常用）
//   * 'ontouchstart' in window - 检测触控事件支持
//   * window.TouchEvent !== undefined - 检测TouchEvent构造函数
//   * window.matchMedia('(pointer: coarse)').matches - 通过媒体查询检测触控
//   * 通过创建触控事件并检查其属性的间接方法
//   * PointerEvent API检测 (pointerType属性)

// - 需要协调一致的触控相关特性：
//   * 确保Touch事件和Pointer事件行为一致
//   * 如果设置为移动设备，需要同时伪造相应的User-Agent和屏幕尺寸
//   * 触控精度和操作行为应与伪造的设备类型匹配
//   * CSS的hover/active/focus状态应与触控设备的行为一致
//   * pointer:coarse/fine媒体查询结果应与触控设置匹配

// - 防御现代指纹检测技术：
//   * 防御通过事件触发顺序检测真实触控能力（如触发touchstart但无法正确处理touchmove）
//   * 防御通过多点触控手势（如捏合缩放）行为不一致检测
//   * 防御通过触控延迟和精度特征进行的检测
//   * 处理passive event listener行为差异的检测
//   * 处理触控事件与鼠标事件转换时间差的检测

// - 与其他指纹项的协调：
//   * 如设置移动设备的触控点，确保与设备像素比、屏幕分辨率、User-Agent等保持一致
//   * 如设置为桌面设备，确保相关触控事件处理逻辑也与桌面环境一致

10、canvas画布指纹【噪音 真实 可外部自定义字符串来固定噪音】
文件路径(已验证): src/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
文件路径(已验证): src/third_party/blink/renderer/platform/graphics/canvas_2d_layer_bridge.cc
文件路径(已验证): src/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
文件路径(已验证): src/cc/paint/paint_recorder.cc
文件路径(已验证): src/gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
文件路径(已验证): src/third_party/blink/renderer/platform/graphics/image_data_buffer.h
文件路径(已验证): src/third_party/blink/renderer/core/html/canvas/canvas_context_creation_attributes_core.h
文件路径(已验证): src/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc
文件路径(已验证): src/third_party/blink/renderer/platform/graphics/skia/skia_utils.cc
文件路径(已更新): src/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc
文件路径(已验证): src/third_party/blink/renderer/core/imagebitmap/image_bitmap.cc
文件路径(已验证): src/third_party/blink/renderer/platform/graphics/bitmap_image.cc
文件路径(已更新): src/third_party/blink/renderer/platform/graphics/graphics_context.cc
文件路径(已更新): src/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
文件路径(已验证): src/third_party/blink/renderer/platform/graphics/bitmap_image_metrics.cc
文件路径(已验证): src/third_party/blink/renderer/platform/graphics/graphics_context.cc
文件路径(已更新): src/third_party/blink/renderer/platform/graphics/skia/skia_utils.cc

// 修改实现细节：
// - 核心修改点在于拦截 Canvas 绘制完成后读取像素数据的过程，例如 toDataURL()、toBlob() 或 getImageData() 方法的实现。可以在数据返回之前，向像素数据中注入细微的噪音（修改部分像素的颜色值）。
// - src/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc 和 src/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc 是处理 Canvas 2D 绘制命令的地方，理解绘制流程有助于找到注入噪音的时机。
// - src/third_party/blink/renderer/platform/graphics/image_data_buffer.h (及其相关实现) 定义了存储 Canvas 像素数据的数据结构，是直接修改像素数据的地方。
// - src/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc 实现了HTML Canvas元素，包括toDataURL和toBlob方法，是读取像素数据的关键入口点。
// - src/third_party/blink/renderer/modules/offscreencanvas/offscreen_canvas.cc 实现了离屏Canvas，现代指纹检测可能使用离屏Canvas避开常规保护。
// - src/third_party/blink/renderer/core/imagebitmap/image_bitmap.cc 处理ImageBitmap对象，通过createImageBitmap API可以从Canvas获取图像数据。
// - src/third_party/blink/renderer/platform/graphics/bitmap_image.cc 和 src/third_party/blink/renderer/platform/graphics/bitmap_image_metrics.cc 处理位图图像，影响像素数据的存储和处理。
// - src/third_party/blink/renderer/platform/graphics/paint/paint_canvas.cc 和 src/third_party/blink/renderer/platform/graphics/graphics_context.cc 提供底层绘图功能，影响Canvas渲染管线。
// - src/third_party/blink/renderer/core/exported/web_canvas_rendering_context_2d_impl.cc 是Canvas 2D上下文的Web实现，处理与JavaScript层的交互。
// - src/third_party/skia/src/core/SkCanvas.cpp 是底层Skia绘图库的Canvas实现，所有Canvas操作最终都会调用这个库。
// - src/third_party/blink/renderer/platform/graphics/skia/skia_utils.cc 提供Skia相关工具函数，处理像素格式转换等操作。

// - 为了实现固定的噪音，可以基于输入的固定字符串生成一个确定的随机数种子，然后使用这个种子来生成噪音数据并应用到 Canvas 像素上。具体实现方法：
//   * 哈希处理输入的字符串生成确定性种子
//   * 使用伪随机数生成器(PRNG)生成噪音模式
//   * 对每个像素应用微小的、肉眼几乎不可见的修改
//   * 确保噪音在整个图像上分布均匀

// - 针对现代Canvas指纹检测技术的防护策略：
//   * 防御内容检测：某些检测会绘制特定内容并检查像素值，需要检测这些特征内容并针对性处理
//   * 防御绘制命令序列检测：某些检测会分析绘制命令执行后的像素变化模式
//   * 防御性能特征检测：通过测量绘制操作的时间来识别设备特征
//   * 防御WebGL和2D Canvas交叉验证：现代检测可能同时使用两种渲染上下文并比对结果
//   * 防御Canvas黑盒检测：一些检测通过在不同条件下(旋转、缩放等)多次绘制相同内容来识别噪音模式

// - Canvas指纹保护需注意的关键点：
//   * 一致性：确保相同输入产生相同噪音，保持指纹的稳定性
//   * 微小性：噪音应足够小，不影响用户体验，但又足以改变指纹
//   * 全面性：覆盖所有可能的Canvas数据获取路径，包括直接/间接方法
//   * 防检测：噪音模式本身不应成为新的识别特征
//   * 性能影响：确保噪音注入不会显著影响性能

// - 与相关指纹项的协调：
//   * WebGL指纹：确保Canvas和WebGL的噪音策略一致
//   * 硬件加速：需处理硬件加速和软件渲染模式下的一致性
//   * 字体渲染：Canvas文本渲染与字体指纹保护需协调
//   * 色彩管理：与颜色深度、色彩空间等指纹项协调

11、canvas字体指纹【自定义（自定义就是可以随机自主保护一部分字体避免被检测到） 真实】
文件路径(已验证): src/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
文件路径(已验证): src/third_party/blink/renderer/platform/fonts/font_selector.cc
文件路径(已验证): src/third_party/blink/renderer/platform/fonts/font_cache.cc
文件路径(已验证): src/ui/gfx/platform_font_skia.cc
文件路径(已验证): src/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
文件路径(已验证): src/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.h
文件路径(已验证): src/third_party/blink/renderer/core/html/canvas/text_metrics.cc
文件路径(已验证): src/third_party/blink/renderer/core/html/canvas/text_metrics.h
文件路径(已验证): src/third_party/blink/renderer/platform/fonts/font_metrics.cc
文件路径(已验证): src/third_party/blink/renderer/platform/fonts/font_metrics.h
文件路径(已验证): src/third_party/blink/renderer/platform/fonts/font_description.cc
文件路径(已验证): src/third_party/blink/renderer/platform/fonts/skia/skia_text_metrics.cc
文件路径(已验证): src/third_party/blink/renderer/platform/fonts/font_fallback_map.cc
文件路径(已验证): src/third_party/blink/renderer/platform/fonts/simple_font_data.cc
文件路径(已验证): src/third_party/blink/renderer/platform/fonts/shaping/shape_result.cc

// 修改实现细节：
// - Canvas 字体指纹通常是通过在 Canvas 上绘制特定文本，然后获取绘制结果的像素数据来生成的。修改的核心在于影响 Canvas 绘制文本时的字体选择和渲染过程。
// 
// - 主要修改点：
//   1. src/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc 中的 fillText(), strokeText() 和 DrawTextInternal() 方法
//      这些是Canvas文本渲染的入口点，在这里可以拦截文本渲染请求，根据保护策略决定如何处理。
//
//   2. src/third_party/blink/renderer/platform/fonts/font_selector.cc 和 src/third_party/blink/renderer/platform/fonts/font_cache.cc 
//      负责字体的查找、匹配和缓存。在这里拦截字体查找请求，可以：
//      - 返回伪造的字体对象
//      - 修改真实字体的加载和缓存逻辑，使其对特定的字体返回不同的结果
//      - 修改字体特征和度量信息，如字符宽度、高度、基线等
//
//   3. src/third_party/blink/renderer/core/html/canvas/text_metrics.cc 实现了measureText()方法返回的TextMetrics对象
//      现代指纹检测技术经常使用这个API来获取字体特征，需要修改以下属性的计算：
//      - width, actualBoundingBoxLeft, actualBoundingBoxRight (水平方向特征)
//      - fontBoundingBoxAscent, fontBoundingBoxDescent (字体边界框特征)
//      - actualBoundingBoxAscent, actualBoundingBoxDescent (实际渲染边界特征)
//      - alphabeticBaseline, hangingBaseline, ideographicBaseline (基线信息)
//      - emHeightAscent, emHeightDescent (em高度特征)
//
//   4. src/third_party/blink/renderer/platform/fonts/font_metrics.cc 和 font_metrics.h 定义了字体度量信息
//      这些度量信息直接影响文本渲染和TextMetrics的结果，修改这些值可以改变字体指纹
//
//   5. src/third_party/blink/renderer/platform/fonts/font_description.cc 处理字体描述信息
//      包括字体族、大小、粗细、风格等，修改这里可以影响字体选择和匹配过程
//
//   6. src/third_party/blink/renderer/platform/fonts/font_fallback_map.cc 处理字体回退机制
//      当请求的字体不可用时，浏览器会选择回退字体，这个过程也会影响字体指纹
//
//   7. src/third_party/blink/renderer/platform/fonts/simple_font_data.cc 和 src/third_party/blink/renderer/platform/fonts/shaping/shape_result.cc
//      这些文件处理字形塑形和布局，影响文本最终的渲染结果
//
// - 针对最新指纹检测技术的防护策略：
//   1. 应对OpenType特性检测：现代指纹技术会检测特定字体的OpenType特性支持情况，
//      需要在font_selector.cc中处理字体特性查询，确保返回一致的特性支持信息
//
//   2. 应对字体渲染微小差异检测：检测工具会比较像素级的渲染差异，
//      在DrawTextInternal()方法中添加微小随机偏移或模糊效果
//
//   3. 应对基于罕见字符的检测：某些检测使用罕见Unicode字符测试字体支持情况，
//      需要在font_fallback_map.cc中统一回退字体的选择逻辑
//
//   4. 应对字体形状差异检测：在shape_result.cc中修改字形塑形结果，
//      使得相同的文本在不同字体下有相似的视觉效果
//
//   5. 应对TextMetrics API精确检测：修改text_metrics.cc中所有度量属性的计算方法，
//      使其与选择的伪造字体特征一致
//
//   6. 应对国际化文本渲染检测：处理不同语言文本的渲染行为，
//      确保在font_selector.cc中对非拉丁字符集的字体选择逻辑也进行一致性处理
//
// - 为了实现"随机自主保护一部分字体"功能：
//   1. 在font_cache.cc中实现一个字体保护列表机制，根据配置决定哪些字体需要保护
//   2. 对于保护列表中的字体，可以采用以下策略：
//      - 完全替换：将请求的字体完全替换为另一个相似但不同的字体
//      - 特征修改：保留原字体但修改其部分特征值，如度量信息
//      - 渲染扰动：在文本渲染过程中添加微小的一致性扰动
//   3. 使用固定的随机种子，确保相同的字体每次都应用相同的保护策略，
//      避免每次刷新产生不同的字体指纹
//
// - 综合处理方法：
//   1. 创建一个中央字体指纹控制器，管理所有字体保护策略
//   2. 在font_selector.cc和font_cache.cc中添加钩子，将字体查询请求转发给控制器
//   3. 控制器根据配置（自定义保护列表或真实模式）决定如何处理每个字体请求
//   4. 在text_metrics.cc中添加钩子，确保measureText返回的度量信息与渲染结果一致
//   5. 在base_rendering_context_2d.cc的DrawTextInternal方法中添加钩子，
//      确保文本渲染过程与字体保护策略一致

12、css字体指纹【噪音，真实】
// ... 现有内容保持不变 ...

13、WebRTC【自动替换（自动把当前代理ip替换，达到避免检测出代理效果） 自定义（自定义可以支持设置内网和外网ip） 真实】
文件路径(已验证): src/content/browser/webrtc/webrtc_ip_permissions_browsertest.cc
文件路径(已验证): src/content/browser/webrtc/webrtc_internals.cc
文件路径(已验证): src/third_party/blink/public/common/peerconnection/webrtc_ip_handling_policy.h
文件路径(已验证): src/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
文件路径(已验证): src/content/browser/webrtc/webrtc_internals_message_handler.cc
文件路径(已验证): src/services/network/public/cpp/p2p_param_traits.h
文件路径(已验证): src/net/base/network_interfaces.h
文件路径(已验证): src/services/network/p2p/socket_manager.cc
文件路径(已验证): src/services/network/p2p/socket_manager.h
文件路径(已验证): src/services/network/network_service.cc
文件路径(已验证): src/services/network/network_service.h
文件路径(已验证): src/third_party/blink/renderer/modules/peerconnection/rtc_ice_candidate.cc
文件路径(已验证): src/chrome/browser/media/webrtc/webrtc_event_log_manager.cc
文件路径(已验证): src/third_party/blink/renderer/modules/peerconnection/rtc_session_description.cc
文件路径(已更新): src/third_party/blink/renderer/modules/peerconnection/rtc_session_description.cc
文件路径(已更新): src/third_party/blink/renderer/modules/peerconnection/rtc_session_description.cc
文件路径(已更新): src/services/network/p2p/socket_manager.cc
文件路径(已更新): src/services/network/p2p/socket_manager.cc
文件路径(已验证): src/third_party/blink/renderer/modules/peerconnection/rtc_stats_report.cc
文件路径(已更新): src/third_party/blink/renderer/modules/peerconnection/rtc_stats_report.cc
文件路径(已更新): src/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
文件路径(已更新): src/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
文件路径(已更新): src/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
文件路径(未找到): src/third_party/webrtc/p2p/base/port_allocator.cc
文件路径(未找到): src/third_party/webrtc/p2p/client/basic_port_allocator.cc

// 修改实现细节：
// - WebRTC 通过 ICE 框架发现本地和公共 IP 地址作为候选地址进行连接。修改的核心在于拦截或修改 ICE 收集候选地址的过程。
// - src/net/base/network_interfaces.cc 负责获取本地网络接口及其 IP 地址列表。修改这个文件中的函数，使其返回伪造的本地 IP 地址列表，是控制内网 IP 泄露的关键点。
// - src/services/network/p2p/socket_manager.cc 处理 P2P 连接的建立，包括 ICE 候选的收集和交换。需要修改这里的逻辑，确保 ICE 框架使用伪造的 IP 地址进行候选收集。
// - src/services/network/network_service.cc 提供网络服务，确保通过这些接口获取到的也是伪造的 IP 地址。
// - src/third_party/blink/renderer/modules/peerconnection/rtc_ice_candidate.cc 处理ICE候选地址的表示和处理，可以在此修改候选地址的生成和使用。
// - src/chrome/browser/media/webrtc/webrtc_event_log_manager.cc 管理WebRTC事件日志，与网络连接和候选地址收集过程相关。
// - 实现"自动替换"代理 IP，需要在获取公共 IP 地址时，识别出代理的出口 IP，并将其替换为伪造的 IP 地址。实现"自定义"则需要允许用户配置内网和外网 IP 列表，并在收集候选地址时使用这些配置的 IP。
//
// - 防护现代WebRTC指纹检测技术需要额外修改以下方面：
//
//   1. SDP会话描述防护：
//      - 在 src/third_party/blink/renderer/modules/peerconnection/rtc_session_description.cc 和 src/third_party/webrtc/pc/session_description.cc 中
//        修改SDP生成逻辑，统一不同环境下的编解码器顺序、媒体能力描述和格式偏好
//      - 在 src/third_party/webrtc/pc/sdp_serializer.cc 中标准化SDP格式，确保在不同浏览器环境下生成一致的SDP字符串
//      - 特别注意 a=fingerprint 行和 a=ice-options 行，它们包含可识别的特征
//
//   2. DTLS安全指纹防护：
//      - 在 src/third_party/webrtc/pc/dtls_transport.cc 中修改DTLS传输层的初始化和配置
//      - 在 src/third_party/webrtc/rtc_base/ssl_fingerprint.cc 中修改SSL证书指纹的生成和处理逻辑
//      - 确保在不同会话中使用一致的DTLS指纹，防止通过证书指纹跟踪用户
//
//   3. 统计数据和指标防护：
//      - 在 src/third_party/blink/renderer/modules/peerconnection/rtc_stats_report.cc 和 src/third_party/webrtc/stats/rtc_stats_collector.cc 中
//        过滤或规范化可能暴露设备特征的统计指标
//      - 特别注意处理网络类型、延迟数据、带宽估计等能够揭示用户网络环境的信息
//      - 标准化RTCStatsReport中返回的硬件和网络特征数据
//
//   4. 媒体能力和编解码器防护：
//      - 在 src/third_party/webrtc/media/engine/webrtc_media_engine.cc 中统一媒体引擎的能力报告
//      - 标准化支持的编解码器列表、视频分辨率范围和音频采样率，避免通过独特的媒体能力组合识别设备
//      - 确保在不同设备和浏览器版本中展示一致的媒体处理能力
//
//   5. ICE收集时间模式防护：
//      - 在 src/third_party/webrtc/p2p/base/port_allocator.cc 和 src/third_party/webrtc/p2p/client/basic_port_allocator.cc 中
//        修改ICE候选收集的时间模式，防止通过收集顺序和时间间隔识别网络环境
//      - 实现一致的ICE收集行为，包括候选类型的顺序和触发时机
//      - 调整收集延迟和超时参数，使其在不同网络环境下表现一致
//
//   6. WebRTC配置标准化：
//      - 在 src/third_party/blink/renderer/modules/peerconnection/rtc_configuration.cc 和 src/third_party/webrtc/api/peer_connection_interface.cc 中
//        标准化WebRTC的配置参数，如ICE服务器、传输策略和候选类型政策
//      - 统一ICE组件配置，确保RTCPeerConnection在不同环境中表现一致
//      - 标准化音视频约束和偏好设置，防止通过特定的配置组合进行识别
//
// - 综合防护策略应该协调所有这些修改点，确保它们之间的一致性：
//   * IP地址替换：不仅替换可见的IP地址，还要确保相关的网络标识符（如网络类型、接口名称）也保持一致
//   * 时间特征掩蔽：调整连接建立、ICE收集、DTLS握手的时间特征，防止通过时序模式识别
//   * 配置一致性：确保所有配置参数、媒体能力和优先级设置保持内部一致，避免逻辑矛盾
//   * 会话持久性：在指定的指纹配置下保持相同的会话特征，确保用户在多次连接中不会因WebRTC特征差异而被识别

14、WebGL图像：【噪音 真实】
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
文件路径(已验证): src/gpu/command_buffer/client/gles2_interface.h
文件路径(已验证): src/gpu/command_buffer/client/gles2_implementation.cc
文件路径(已验证): src/gpu/command_buffer/service/gl_context_virtual.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl2_rendering_context.cc
文件路径(已验证): src/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_shader.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_program.cc
文件路径(已验证): src/gpu/command_buffer/service/shader_translator.cc
文件路径(已验证): src/gpu/command_buffer/service/program_manager.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_framebuffer.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_texture.cc
文件路径(已验证): src/gpu/command_buffer/service/texture_manager.cc
文件路径(未找到): src/third_party/blink/renderer/modules/webgl/webgl_extensions.cc
文件路径(已验证): src/gpu/config/gpu_feature_info.cc
文件路径(已验证): src/gpu/command_buffer/service/context_state.cc
文件路径(已验证): src/gpu/command_buffer/service/feature_info.cc
文件路径(已验证): src/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_context_group.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc

// 修改实现细节：
// - WebGL 图像指纹也是通过在 <canvas> 元素上使用 WebGL API 进行绘制，然后读取像素数据（例如使用 readPixels 或 toDataURL 方法）来生成的。修改的核心在于拦截这个读取像素数据的过程。
// - src/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc 是 WebGL 渲染上下文的基础实现。src/gpu/command_buffer/client/gles2_implementation.cc 是 GPU 进程中 GLES2 API 的实现，负责与 GPU 驱动交互。
// - 可以在 gles2_implementation.cc 中与 readPixels 或其他读取 framebuffer 相关的函数中，在将像素数据返回给调用方之前，向数据中注入细微的噪音。
// - 另一种方法是在 webgl_rendering_context_base.cc 中拦截 toDataURL 等方法，在获取到像素数据后进行修改。
// - src/gpu/command_buffer/service/gl_context_virtual.cc 提供虚拟化的GL上下文，对WebGL渲染状态和性能有影响，可修改此处实现更深层次的指纹保护。
// - src/third_party/blink/renderer/modules/webgl/webgl2_rendering_context.cc 处理WebGL2特有的指纹信息，对于支持WebGL2的浏览器很重要。
// - src/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc 实现HTML Canvas元素，是WebGL指纹生成的起点，可在此处添加额外保护层。
// - 注入噪音的方式与 2D Canvas 类似，可以根据需要（真实、噪音）决定是否修改像素数据，或者使用固定种子生成噪音。
//
// - 针对最新WebGL指纹检测技术，需要进一步修改以下方面：
//
//   1. 着色器编译和程序链接行为标准化：
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl_shader.cc 和 src/gpu/command_buffer/service/shader_translator.cc 中
//        修改着色器编译逻辑，标准化编译错误和警告信息，防止通过着色器编译行为差异识别GPU
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl_program.cc 和 src/gpu/command_buffer/service/program_manager.cc 中
//        规范化程序链接过程和验证结果，确保在不同GPU和驱动上呈现一致的行为
//      - 特别处理着色器精度限定符和变量类型的处理差异，这是现代指纹技术的重点检测项
//
//   2. 浮点精度和纹理行为标准化：
//      - 在 src/gpu/command_buffer/client/gles2_implementation.cc 的 readPixels 实现中
//        增加针对浮点精度测试的防护，确保浮点值的一致性
//      - 修改 src/third_party/blink/renderer/modules/webgl/webgl_texture.cc 和 src/gpu/command_buffer/service/texture_manager.cc 中
//        的纹理处理逻辑，规范化纹理过滤、环绕模式和mipmap生成行为
//      - 统一不同硬件和驱动下的浮点运算结果，特别是在边缘情况下的表现
//
//   3. WebGL扩展和功能报告标准化：
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl_extensions.cc 中统一扩展支持列表和行为
//      - 修改 src/gpu/config/gpu_feature_info.cc 和 src/gpu/command_buffer/service/feature_info.cc 中的功能检测逻辑
//      - 特别注意 WEBGL_debug_renderer_info 扩展的处理，在 src/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc 中
//        返回规范化的渲染器和供应商信息，防止通过这些信息直接识别GPU
//
//   4. 帧缓冲区和渲染行为一致性：
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl_framebuffer.cc 中规范化帧缓冲区行为
//      - 修改 src/gpu/command_buffer/service/context_state.cc 中的状态管理，确保渲染状态变化的一致性
//      - 在 src/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc 中添加规范化处理
//        防止通过图像格式转换的细微差异进行指纹识别
//
//   5. 上下文和资源管理标准化：
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl_context_group.cc 中标准化上下文组行为
//      - 规范化WebGL上下文的创建、丢失和恢复过程，这些行为在不同硬件和驱动上差异明显
//      - 处理WebGL资源（如缓冲区、纹理）的内存管理行为，避免通过性能特征识别硬件
//
// - 综合防护策略应该协调所有修改点，确保：
//   * 像素数据噪音：在读取像素数据时添加一致性微扰，但保持图像的视觉质量
//   * 着色器行为：规范化着色器编译、链接和执行行为，特别是浮点精度和错误处理
//   * 扩展和功能：提供一致的扩展列表和功能报告，隐藏实际GPU和驱动信息
//   * 渲染行为：统一纹理过滤、抗锯齿和像素光栅化行为的微小差异
//   * 性能特征：掩盖可能通过计时攻击测量的渲染性能特征
//   * 错误处理：标准化WebGL错误报告，避免通过特定错误模式识别硬件
//
// - 针对最先进的指纹技术，特别要关注：
//   * 浮点纹理精度测试防护：现代指纹技术通过精确测量浮点纹理精度来识别GPU
//   * 渲染一致性测试防护：处理角度、直线和多边形渲染时的微小像素级差异
//   * 抗锯齿和抖动模式防护：统一这些通常由硬件实现的渲染特性
//   * 着色器编译时间防护：掩盖不同复杂度着色器的编译时间差异

15、WebGL元数据：【自定义 真实】
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
文件路径(已验证): src/gpu/command_buffer/client/gles2_implementation.cc
文件路径(已验证): src/gpu/command_buffer/client/gpu_control.h
文件路径(已验证): src/gpu/command_buffer/common/capabilities.h
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc
文件路径(已验证): src/gpu/config/gpu_info.cc
文件路径(已验证): src/gpu/config/gpu_info_collector.cc
文件路径(已验证): src/gpu/command_buffer/service/feature_info.cc
文件路径(未找到): src/third_party/blink/renderer/modules/webgl/webgl_extensions.cc
文件路径(已更新): src/third_party/blink/renderer/modules/webgl/webgl_extension.cc
文件路径(已验证): src/gpu/config/gpu_driver_bug_workarounds.cc
文件路径(已验证): src/gpu/config/gpu_feature_info.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl2_rendering_context_base.cc
文件路径(已验证): src/gpu/command_buffer/service/context_state.cc
文件路径(已验证): src/gpu/config/gpu_preferences.cc

// 修改实现细节：
// - WebGL 元数据包括通过 getContextAttributes()、getParameter()（例如获取 VERSION, RENDERER, VENDOR, SUPPORTED_EXTENSIONS 等）以及其他 API 获取的信息，这些信息反映了 GPU、驱动、API 版本和支持的特性。
// - 主要的修改点在 src/gpu/command_buffer/client/gles2_implementation.cc 和 src/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc。
// - 需要在 gles2_implementation.cc 中拦截获取 GPU 参数和扩展列表的函数调用，返回伪造的信息。例如，修改 GetString() 返回的 VERSION, RENDERER, VENDOR 字符串，修改 GetIntegerv() 返回的参数值，以及修改 GetExtensions() 返回的支持扩展列表。
// - capabilities.h 定义了 GPU 能力的数据结构，理解这个结构有助于知道哪些值是可以伪造的。gpu_control.h 通常不需要修改。
// - 伪造时可以参考常见显卡型号的 WebGL 参数，或者根据固定字符串生成伪造的参数，确保参数之间的逻辑一致性。
//
// - 针对最新WebGL元数据指纹检测技术，需要进一步修改以下方面：
//
//   1. GPU识别信息防护：
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc 中修改WEBGL_debug_renderer_info扩展
//        这是直接暴露GPU型号和厂商信息的主要来源，需要标准化UNMASKED_RENDERER_WEBGL和UNMASKED_VENDOR_WEBGL返回值
//      - 在 src/gpu/config/gpu_info.cc 和 src/gpu/config/gpu_info_collector.cc 中修改GPU信息收集逻辑
//        确保WebGL获取的GPU信息与伪造的指纹配置一致
//      - 创建一个统一的GPU标识符映射表，将实际GPU信息映射到通用或伪造的标识符
//
//   2. 版本字符串和语言版本标准化：
//      - 在 src/gpu/command_buffer/client/gles2_implementation.cc 中修改GetString函数
//        统一返回标准化的VERSION和SHADING_LANGUAGE_VERSION字符串
//      - 确保版本字符串格式一致（如"WebGL 1.0"或"OpenGL ES GLSL ES 1.0"）
//      - 屏蔽可能泄露驱动版本的特定格式和后缀
//
//   3. 参数限制和能力标准化：
//      - 修改处理GetIntegerv、GetFloatv等函数的逻辑，标准化以下关键参数：
//        * MAX_TEXTURE_SIZE和MAX_RENDERBUFFER_SIZE（纹理和渲染缓冲区最大尺寸）
//        * MAX_VIEWPORT_DIMS（视口最大尺寸）
//        * MAX_VERTEX_ATTRIBS（最大顶点属性数量）
//        * MAX_VARYING_VECTORS（最大传递变量向量数）
//        * MAX_VERTEX_UNIFORM_VECTORS和MAX_FRAGMENT_UNIFORM_VECTORS（着色器最大统一变量）
//      - 在 src/gpu/command_buffer/common/capabilities.h 中理解这些参数的存储结构
//      - 确保参数之间的逻辑一致性，避免设置矛盾的能力值
//
//   4. 扩展列表规范化：
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl_extensions.cc 和
//        src/third_party/blink/renderer/modules/webgl/webgl_extensions_util.cc 中
//        规范化getSupportedExtensions()返回的扩展列表
//      - 创建一个固定的"标准"扩展集合，避免根据实际硬件能力动态变化
//      - 特别控制高风险扩展，如：
//        * WEBGL_debug_renderer_info（直接暴露GPU信息）
//        * WEBGL_debug_shaders（可能暴露着色器编译器特征）
//        * EXT_texture_filter_anisotropic（显示硬件过滤能力）
//
//   5. 驱动工作区和错误处理标准化：
//      - 在 src/gpu/config/gpu_driver_bug_workarounds.cc 中规范化驱动bug工作区
//      - 在 src/gpu/command_buffer/service/context_state.cc 中标准化状态管理行为
//      - 确保错误处理行为在不同硬件和驱动上表现一致
//      - 规范化状态查询函数的行为，如getParameter、getShaderPrecisionFormat等
//
//   6. WebGL2特有功能和参数防护：
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl2_rendering_context_base.cc 中
//        处理WebGL2特有参数和功能报告
//      - 标准化WebGL2新增的参数，如：
//        * 整数格式和纹理支持（如RGB32I、RGBA32I等）
//        * 变换反馈和实例化绘制的限制
//        * 存储缓冲区(Storage Buffer)的限制
//        * 采样器数量限制
//      - 确保WebGL2的功能报告与WebGL1保持一致的伪装策略
//
//   7. 性能和计时特征掩蔽：
//      - 掩蔽通过精确计时API测量的WebGL操作性能特征
//      - 规范化纹理上传、缓冲区操作和着色器编译的计时特征
//      - 模拟一致的性能模式，避免通过性能分析识别硬件
//
// - 综合防护策略应协调所有修改点，确保：
//   * 参数一致性：所有报告的参数和限制之间保持逻辑一致关系
//   * 功能对称性：如果声明支持某扩展，确保相关功能参数也配置正确
//   * 版本兼容性：确保版本字符串与功能支持相匹配
//   * 隐藏特征：屏蔽可用于唯一识别的特殊硬件特性
//   * 适当降级：在必要时降低报告的能力，以提高跨设备的一致性
//
// - "自定义"模式实现：
//   * 创建预定义的GPU配置文件，模拟常见的GPU型号和驱动版本
//   * 允许用户选择特定的GPU配置，如"Intel HD Graphics 4000"、"NVIDIA GeForce GTX 1060"等
//   * 根据选择的配置，提供一致的参数集、扩展列表和版本字符串
//   * 确保选择的配置在所有WebGL相关API中表现一致

16、WebGPU【基于WebGL 真实 禁用】
文件路径(已验证): src/third_party/blink/web_tests/external/wpt/interfaces/webgpu.idl
文件路径(已验证): src/gpu/command_buffer/client/webgpu_implementation.cc
文件路径(已验证): src/gpu/config/gpu_info_collector.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgpu/gpu.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgpu/gpu_device.cc
文件路径(已验证): src/gpu/command_buffer/service/webgpu_decoder_impl.cc
文件路径(已验证): src/gpu/config/webgpu_blocklist.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgpu/gpu_adapter.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgpu/gpu_supported_features.cc
文件路径(已更新): src/third_party/blink/renderer/platform/p2p/port_allocator.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgpu/gpu_shader_module.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgpu/gpu_compute_pipeline.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webgpu/gpu_render_pipeline.cc
文件路径(已验证): src/third_party/dawn/src/dawn/native/ShaderModule.cpp
文件路径(已验证): src/third_party/dawn/src/dawn/native/Features.cpp
{{ ... }}
文件路径(未找到): src/third_party/dawn/src/dawn/native/Adapter.cpp
文件路径(未找到): src/third_party/dawn/src/dawn/native/Device.cpp
文件路径(已验证): src/third_party/blink/renderer/modules/webgpu/gpu_queue.cc
文件路径(未找到): src/third_party/dawn/src/dawn/native/ValidationUtils.cpp

// 修改实现细节：
// - WebGPU 是新一代的 Web 图形 API，提供对 GPU 硬件更低级别的访问。WebGPU 指纹可能通过检查其可用性、支持的特性、适配器信息等来生成。
// - 要禁用 WebGPU 指纹，最直接的方式是禁用 WebGPU 功能本身。这通常通过命令行标志或特性开关控制。
// - src/gpu/config/gpu_info_collector.cc 负责收集 GPU 的信息，可以在这里修改报告 WebGPU 能力的逻辑，使其报告不支持 WebGPU。
// - src/gpu/command_buffer/client/webgpu_implementation.cc 是 WebGPU API 的实现，如果需要伪造信息，可以在这里拦截获取适配器信息、设备能力等 API 调用，返回伪造的数据。
// - src/third_party/blink/web_tests/external/wpt/interfaces/webgpu.idl 文件定义了 WebGPU 的接口，是理解 API 的参考。
//
// - 针对最新WebGPU指纹检测技术，需要进一步修改以下方面：
//
//   1. 适配器信息标准化：
//      - 在 src/third_party/blink/renderer/modules/webgpu/gpu_adapter.cc 中修改 requestAdapter 返回的信息
//        标准化或模糊化 vendor、architecture、device 和 description 等关键识别信息
//      - 在 src/third_party/dawn/src/dawn/native/Adapter.cpp 中处理底层适配器枚举和属性报告
//        确保不同GPU厂商和型号返回一致的标识符信息
//      - 创建预定义的适配器配置文件，模拟常见GPU型号的WebGPU适配器特性
//
//   2. 特性和限制标准化：
//      - 在 src/third_party/blink/renderer/modules/webgpu/gpu_supported_features.cc 中标准化特性支持列表
//        创建固定的特性集合，如"timestamp-query"、"depth-clip-control"、"texture-compression-bc"等
//      - 在 src/third_party/blink/renderer/modules/webgpu/gpu_supported_limits.cc 中统一限制参数报告
//        规范化以下关键限制：
//        * maxTextureDimension2D（最大2D纹理尺寸）
//        * maxBufferSize（最大缓冲区大小）
//        * maxBindGroups（最大绑定组数量）
//        * maxBindingsPerBindGroup（每绑定组最大绑定数）
//        * maxDynamicUniformBuffersPerPipelineLayout（动态统一缓冲区上限）
//        * maxComputeWorkgroupSizeX/Y/Z（计算着色器工作组大小）
//      - 在 src/third_party/dawn/src/dawn/native/Features.cpp 中标准化Dawn特性管理
//        确保特性启用逻辑不会因硬件差异而变化
//
//   3. 着色器编译行为规范化：
//      - 在 src/third_party/blink/renderer/modules/webgpu/gpu_shader_module.cc 和
//        src/third_party/dawn/src/dawn/native/ShaderModule.cpp 中统一着色器编译行为
//      - 规范化着色器验证结果和错误报告，避免通过编译器行为差异识别GPU驱动
//      - 确保WGSL和SPIR-V着色器的处理行为一致，不暴露特定于硬件的优化差异
//      - 处理着色器编译时间特征，防止通过性能分析检测硬件差异
//
//   4. 管线和格式支持标准化：
//      - 在 src/third_party/blink/renderer/modules/webgpu/gpu_compute_pipeline.cc 和
//        src/third_party/blink/renderer/modules/webgpu/gpu_render_pipeline.cc 中规范化管线创建行为
//      - 统一格式支持报告，如纹理格式、存储格式、顶点格式等
//      - 确保不同GPU架构下报告一致的格式能力，避免通过格式支持组合识别硬件
//
//   5. 实现可配置的禁用机制：
//      - 在 src/third_party/blink/renderer/modules/webgpu/gpu.cc 中实现完全禁用机制
//        可以通过以下方式实现：
//        * 使 navigator.gpu 返回 null 或未定义
//        * 或返回一个受限的 GPU 对象，但 requestAdapter 始终解析为 null
//        * 或抛出适当的安全或权限异常
//      - 利用 src/gpu/config/webgpu_blocklist.cc 实现基于策略的选择性禁用
//        可以针对特定网站或特定使用场景禁用WebGPU
//
//   6. Dawn后端实现的一致性：
//      - 在 src/third_party/dawn/src/dawn/native/Device.cpp 中确保设备行为一致性
//      - 在 src/third_party/blink/renderer/modules/webgpu/gpu_queue.cc 中规范化队列操作行为
//      - 在 src/third_party/dawn/src/dawn/native/ValidationUtils.cpp 中标准化验证逻辑
//        避免通过验证行为差异识别特定实现
//
// - "基于WebGL"模式实现：
//   * 创建与WebGL指纹保护协调一致的WebGPU配置
//   * 确保WebGPU报告的GPU信息与WebGL报告的信息完全匹配
//   * 模拟相同的特性支持模式和限制参数，保持逻辑一致性
//
// - "禁用"模式实现：
//   * 完全禁止navigator.gpu API的使用
//   * 或提供一个模拟的API实现，但所有操作都返回不支持或失败
//   * 确保禁用方式不会暴露被禁用的事实（某些指纹检测可能专门检测WebGPU是否被禁用）
//
// - 综合防护策略应协调WebGPU和WebGL的指纹防护，确保：
//   * 硬件信息一致性：两个API报告的GPU信息保持一致
//   * 能力报告一致性：特性和限制参数在逻辑上与WebGL报告的能力相匹配
//   * 性能特征一致性：确保两个API的性能行为模式相似，防止交叉验证

17、WebGL 内部特性掩码合理浮动、避免异常【 glat	控制纹理/渲染缓冲区尺寸上限	33984	30000~40000	模拟不同显卡的纹理处理能力（值越大"性能越强"）
glmcmts	多重采样抗锯齿（MSAA）特性	16384	10000~20000	调整抗锯齿级别，影响画质和性能（过高可能触发异常）
glmvuv	顶点着色器属性数量限制	4095	3000~5000	模拟低端/高端显卡的顶点处理能力（4095=2^12-1，掩码全开）
glsw	着色器编译功能开关掩码	2147483647	2^31-1 ±1e5	全掩码（2147483647=0x7FFFFFFF）表示支持所有扩展，微调模拟部分功能缺失
glsbvm	帧缓冲区混合模式掩码	2147483647	2^31-1 ±1e5	控制混合算法（如透明度计算），微小变化即可显著改变指纹
gl2mcfuc	WebGL2 最大计算单元数量	200704	150000~250000	伪造 GPU 计算核心数（影响 WebGL2 并行计算能力）
gl2mcvuc	WebGL2 顶点缓冲对象上限	212988	200000~250000	模拟显存容量差异（值越大"显存越大"）
gl2mei	WebGL2 扩展支持掩码	2147483647	2^31-1 ±1e5	禁用/启用特定扩展（如 EXT_texture_filter_anisotropic）以改变功能特性
】
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
文件路径(已验证): src/gpu/command_buffer/client/gles2_implementation.cc
文件路径(已验证): src/gpu/command_buffer/common/gles2_cmd_utils.cc
文件路径(已验证): src/gpu/command_buffer/service/gles2_cmd_decoder.cc
文件路径(已验证): src/gpu/command_buffer/common/capabilities.h
文件路径(已验证): src/third_party/blink/renderer/modules/webgl/webgl2_rendering_context.cc
文件路径(已验证): src/gpu/command_buffer/service/feature_info.cc
文件路径(已验证): src/gpu/command_buffer/service/shader_translator.cc
文件路径(未找到): src/third_party/blink/renderer/modules/webgl/webgl_extensions.cc
文件路径(已验证): src/gpu/command_buffer/service/context_group.cc
文件路径(已验证): src/gpu/command_buffer/service/context_state.cc

// 修改实现细节：
// - 这项指纹关注的是 WebGL 通过 getParameter() 等方法暴露的各种内部参数和能力，特别是那些以掩码形式表示的特性。
// - 修改的核心在于 src/gpu/command_buffer/client/gles2_implementation.cc 和 src/gpu/command_buffer/common/capabilities.h。src/gpu/command_buffer/client/gles2_implementation.cc 负责从 GPU 获取这些参数。src/gpu/command_buffer/common/capabilities.h 定义了存储这些能力参数的数据结构 Capabilities。
// - 需要在 gles2_implementation.cc 中获取 GPU 能力后，在将这些能力传递回 Blink 进程之前，修改 Capabilities 对象中的特定字段。
// - 修改时需要确保伪造的数值在合理范围内，并且不同参数之间保持一致性，以避免触发异常或显得不真实。例如，伪造一个较低的纹理尺寸上限时，相关的参数也应该相应调整。
// - 可以使用一个固定的种子字符串来确定伪造的偏移量或数值，以实现可重现的指纹。
//
// - 针对最新WebGL内部特性掩码指纹检测技术，需要进一步修改以下方面：
//
//   1. 参数值的精确控制和合理浮动：
//      - 在 src/gpu/command_buffer/client/gles2_implementation.cc 中拦截 GetIntegerv、GetFloatv 等参数查询函数
//        针对以下关键参数实现精确控制：
//        * MAX_TEXTURE_SIZE (GL_MAX_TEXTURE_SIZE)：控制纹理尺寸上限
//        * MAX_RENDERBUFFER_SIZE (GL_MAX_RENDERBUFFER_SIZE)：渲染缓冲区尺寸上限
//        * MAX_SAMPLES (GL_MAX_SAMPLES)：多重采样抗锯齿级别
//        * MAX_VERTEX_ATTRIBS (GL_MAX_VERTEX_ATTRIBS)：顶点着色器属性数量
//        * MAX_VERTEX_UNIFORM_VECTORS (GL_MAX_VERTEX_UNIFORM_VECTORS)：顶点着色器统一变量数量
//        * MAX_FRAGMENT_UNIFORM_VECTORS (GL_MAX_FRAGMENT_UNIFORM_VECTORS)：片元着色器统一变量数量
//        * MAX_VARYING_VECTORS (GL_MAX_VARYING_VECTORS)：可变量向量数量
//        * MAX_VERTEX_TEXTURE_IMAGE_UNITS (GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS)：顶点纹理单元数
//      - 在 src/gpu/command_buffer/common/capabilities.h 中理解这些参数的存储结构，确保修改正确的字段
//      - 使用确定性随机算法，基于固定种子生成参数值，确保在相同指纹配置下值保持稳定
//
//   2. WebGL2特有参数的处理：
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl2_rendering_context.cc 中处理WebGL2特有参数
//        特别是以下重要参数：
//        * MAX_ELEMENT_INDEX (GL_MAX_ELEMENT_INDEX)：最大索引值
//        * MAX_UNIFORM_BUFFER_BINDINGS (GL_MAX_UNIFORM_BUFFER_BINDINGS)：统一缓冲区绑定数
//        * MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS (GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS)：变换反馈属性数
//        * MAX_COLOR_ATTACHMENTS (GL_MAX_COLOR_ATTACHMENTS)：最大颜色附件数
//        * MAX_DRAW_BUFFERS (GL_MAX_DRAW_BUFFERS)：最大绘制缓冲区数
//      - 在 src/gpu/command_buffer/service/feature_info.cc 中确保WebGL2特性检测逻辑与参数修改一致
//
//   3. 扩展支持与参数一致性：
//      - 在 src/third_party/blink/renderer/modules/webgl/webgl_extensions.cc 中确保扩展支持报告与掩码值一致
//        特别是处理以下高风险扩展：
//        * WEBGL_debug_renderer_info：控制GPU信息暴露
//        * EXT_texture_filter_anisotropic：控制各向异性过滤能力
//        * OES_texture_float：控制浮点纹理支持
//        * WEBGL_compressed_texture_*：控制各种压缩纹理格式支持
//      - 修改 getSupportedExtensions() 方法，确保返回的扩展列表与修改的掩码值保持一致
//
//   4. 着色器编译和限制参数一致性：
//      - 在 src/gpu/command_buffer/service/shader_translator.cc 中确保着色器编译行为与参数设置一致
//      - 在 src/gpu/command_buffer/service/context_state.cc 中处理状态一致性验证
//      - 在 src/gpu/command_buffer/service/context_group.cc 中管理上下文组参数一致性
//
// - 具体掩码参数的实现：
//   * glat (GL_MAX_TEXTURE_SIZE)：根据指纹配置在30000~40000范围内浮动，模拟不同GPU的纹理能力
//   * glmcmts (GL_MAX_SAMPLES)：在10000~20000范围内浮动，调整MSAA抗锯齿级别
//   * glmvuv (GL_MAX_VERTEX_ATTRIBS)：在3000~5000范围内浮动，模拟不同显卡的顶点处理能力
//   * glsw (着色器编译功能掩码)：在2^31-1±1e5范围内微调，控制着色器功能支持
//   * glsbvm (帧缓冲区混合模式掩码)：在2^31-1±1e5范围内微调，控制混合算法支持
//   * gl2mcfuc (WebGL2计算单元数量)：在150000~250000范围内浮动，模拟GPU计算核心数
//   * gl2mcvuc (WebGL2顶点缓冲对象上限)：在200000~250000范围内浮动，模拟显存容量
//   * gl2mei (WebGL2扩展支持掩码)：在2^31-1±1e5范围内微调，控制WebGL2特定扩展支持
//
// - 综合防护策略应协调所有修改点，确保：
//   * 参数一致性：所有参数值之间保持合理的数学关系，避免逻辑矛盾
//   * 性能合理性：避免设置过高或过低的极端值，可能导致明显的性能异常
//   * 跨会话稳定性：确保相同指纹配置下，参数值在不同会话中保持一致
//   * WebGL1与WebGL2一致性：确保两个版本的共同参数保持逻辑一致
//   * 实际行为一致性：确保API报告的参数值与实际渲染行为相匹配，防止通过功能测试暴露伪装

18、AudioContext【噪音 真实】
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/audio_context.cc
文件路径(已验证): src/media/base/audio_parameters.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/dynamics_compressor_node.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/oscillator_node.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/periodic_wave.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/analyser_node.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/analyser_handler.cc
文件路径(已更新): src/third_party/blink/renderer/modules/webaudio/audio_node.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/offline_audio_context.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/audio_node.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/audio_buffer.cc
文件路径(已验证): src/third_party/blink/renderer/platform/audio/audio_bus.cc
文件路径(已验证): src/third_party/blink/renderer/platform/audio/audio_utilities.cc
文件路径(已验证): src/third_party/blink/renderer/modules/webaudio/audio_worklet_node.cc

// 修改实现细节：
// - AudioContext 指纹通常通过创建 AudioContext 实例，并处理特定的音频信号（例如生成一个振荡器节点，连接到一个分析器节点，然后检查频谱数据或波形数据）来生成。
// - 修改的核心在于影响整个 Web Audio API 的音频处理管线，针对最新指纹检测技术需要从多个关键节点入手：
//
//   1. 动态范围压缩器标准化（最强指纹来源）：
//      - 在 src/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc 中修改压缩器参数计算
//      - 对 threshold、knee、ratio、attack 和 release 等参数的处理进行标准化
//      - 统一不同硬件和操作系统下压缩曲线的非线性特性
//      - 消除因不同硬件实现导致的微小数值差异，这是最强的指纹来源
//
//   2. 振荡器和波形生成标准化：
//      - 在 src/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc 中统一正弦、方波、三角波和锯齿波的生成算法
//      - 在 src/third_party/blink/renderer/modules/webaudio/periodic_wave.cc 中标准化自定义波形的傅里叶系数计算
//      - 确保不同硬件平台生成的波形在数值上保持一致
//
//   3. 频谱分析统一：
//      - 在 src/third_party/blink/renderer/modules/webaudio/analyser_handler.cc 中标准化 FFT 窗口函数和计算
//      - 在 src/third_party/blink/renderer/modules/webaudio/fft_frame.cc 中统一 FFT 算法实现
//      - 确保 getFloatFrequencyData()、getByteFrequencyData() 等方法返回的数据具有一致的特征
//      - 消除由于不同 CPU 优化导致的频谱分析微小差异
//
//   4. 音频缓冲区处理标准化：
//      - 在 src/third_party/blink/renderer/modules/webaudio/audio_buffer.cc 中统一数据存储和访问方式
//      - 在 src/third_party/blink/renderer/platform/audio/audio_bus.cc 中标准化通道数据处理
//      - 确保 getChannelData() 方法返回的浮点数组在各平台上有一致的精度特性
//
//   5. 离线渲染一致性：
//      - 在 src/third_party/blink/renderer/modules/webaudio/offline_audio_context.cc 中规范化渲染过程
//      - 统一不同硬件平台下的渲染计时和结果特征
//      - 处理 startRendering() 的 Promise 完成时间，避免通过性能特征识别硬件
//
//   6. AudioWorklet 保护：
//      - 在 src/third_party/blink/renderer/modules/webaudio/audio_worklet_node.cc 中防止通过自定义处理器检测平台特征
//      - 标准化处理量化误差和处理延迟，避免低级别处理特征暴露
//
//   7. 量化和精度控制：
//      - 在 src/third_party/blink/renderer/platform/audio/audio_utilities.cc 中统一浮点计算精度
//      - 处理不同硬件架构（x86、ARM 等）下的浮点舍入行为差异
//      - 标准化 dBFS（满刻度分贝）转换和其他音频计算的精度特性
//
// - 噪音注入策略：
//   * 在音频数据输出前增加微小的、基于固定种子的随机噪声
//   * 噪声模式应基于用户指纹种子生成，确保会话一致性
//   * 噪声应足够小（通常在 -90dBFS 至 -120dBFS 范围），不影响正常音频质量
//   * 不同音频节点类型可能需要不同的噪声注入策略：
//     - 分析节点数据 (AnalyserNode) 需要在频域和时域都保持一致的噪声模式
//     - 压缩器节点 (DynamicsCompressorNode) 需要在增益曲线上添加微小扰动
//     - 振荡器节点 (OscillatorNode) 需要在波形生成时添加相位微扰
//
// - 防御现代指纹检测技术的特定措施：
//   * 防御基于音频环路测试的检测：网站可能创建一个音频回路并分析输出，需要确保回路中的噪声模式一致
//   * 防御基于 STFT（短时傅里叶变换）特征的检测：现代检测可能分析音频处理的频谱时间特征，需在多个时间片段保持一致的噪声模式
//   * 防御基于压缩器动态特性的检测：动态范围压缩是最强的指纹来源，需特别关注压缩器的时域响应特性
//   * 防御跨会话比对：确保同一用户配置在不同会话中生成一致的指纹，避免通过多次访问发现随机模式
//   * 防御跨节点验证：现代检测可能比较多种节点链的输出结果，验证噪声模式是否一致，需确保所有节点链保持一致的处理特性
//
// - 综合防护策略应协调所有音频处理组件，确保：
//   * 数据一致性：所有音频处理节点生成的数据特征一致
//   * 时间特征一致性：处理延迟和计算时间的模式在不同硬件上表现一致
//   * 精度特征一致性：浮点计算精度和量化误差在不同平台上保持一致
//   * 硬件特征隐藏：消除可能暴露底层硬件架构的处理特征

19、ClientRects【噪音 真实】
文件路径(已验证): src/third_party/blink/renderer/core/dom/element.cc
文件路径(已验证): src/third_party/blink/renderer/core/layout/layout_box.cc
文件路径(已验证): src/third_party/blink/renderer/core/layout/layout_object.cc
文件路径(已验证): src/third_party/blink/renderer/core/layout/adjust_for_absolute_zoom.h
文件路径(已验证): src/third_party/blink/renderer/core/css/css_primitive_value_mappings.h
文件路径(已验证): src/third_party/blink/renderer/core/dom/range.cc
文件路径(已验证): src/third_party/blink/renderer/core/dom/document.cc
文件路径(已验证): src/third_party/blink/renderer/core/geometry/dom_rect.cc
文件路径(已验证): src/third_party/blink/renderer/core/geometry/dom_rect_list.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/visual_viewport.cc
文件路径(已验证): src/third_party/blink/renderer/core/timing/performance_observer.cc
文件路径(已验证): src/third_party/blink/renderer/core/svg/svg_element.cc
文件路径(已验证): src/third_party/blink/renderer/core/animation/css/css_animations.cc
文件路径(已验证): src/third_party/blink/renderer/core/css/css_to_length_conversion_data.cc

// 修改实现细节：
// - ClientRects 指纹是通过调用 Element.getBoundingClientRect()、Element.getClientRects() 或 Range.getClientRects() 方法获取元素或文本范围的布局边界信息来生成的。这些几何数据能够以高精度方式反映浏览器布局引擎的特性，是强大的指纹来源。
//
// - 核心修改文件和策略：
//
//   1. DOMRect 和 DOMRectList 实现：
//      - 在 src/third_party/blink/renderer/core/geometry/dom_rect.cc 中修改 DOMRect 的创建和数值表示
//      - 在 src/third_party/blink/renderer/core/geometry/dom_rect_list.cc 中统一 DOMRectList 的行为
//      - 为矩形坐标和尺寸值添加微小的一致性偏移，确保偏移量足够小（通常为小于0.01px）以避免影响页面视觉布局
//
//   2. Element接口实现：
//      - 在 src/third_party/blink/renderer/core/dom/element.cc 中修改 getBoundingClientRect() 和 getClientRects() 方法
//      - 拦截这些方法返回的结果，在返回给JavaScript前应用一致的噪声模式
//      - 确保相同元素在多次调用时返回一致的结果（使用元素ID或路径作为噪声种子的一部分）
//
//   3. Range接口实现：
//      - 在 src/third_party/blink/renderer/core/dom/range.cc 中修改 getClientRects() 方法
//      - 文本选区的客户端矩形尤其容易反映字体渲染差异，需要特别处理以保持跨平台一致性
//
//   4. 布局引擎处理：
//      - 在 src/third_party/blink/renderer/core/layout/layout_object.cc 和 layout_box.cc 中统一客户端矩形的计算
//      - 处理嵌套元素、溢出内容和多列布局的情况，确保各种复杂布局场景下的一致性
//      - 缩放处理：在 adjust_for_absolute_zoom.h 相关实现中确保不同缩放级别下矩形计算的一致性
//
//   5. SVG元素处理：
//      - 在 src/third_party/blink/renderer/core/svg/svg_element.cc 中处理SVG元素的客户端矩形
//      - SVG元素布局使用不同的渲染路径，需要单独处理以确保与HTML元素保持一致的指纹防护
//
//   6. 视口相关处理：
//      - 在 src/third_party/blink/renderer/core/frame/visual_viewport.cc 中处理视口缩放和滚动对客户端矩形的影响
//      - 确保在视口变化（如滚动、缩放、旋转）后矩形的相对位置保持一致的变化模式
//
//   7. CSS变换和动画处理：
//      - 在 src/third_party/blink/renderer/core/animation/css/css_animations.cc 中处理动画元素的客户端矩形
//      - 确保CSS变换(transform)、过渡(transition)和动画(animation)过程中的矩形计算保持一致
//      - 在 src/third_party/blink/renderer/core/css/css_to_length_conversion_data.cc 中统一长度单位转换
//
//   8. 性能计时防护：
//      - 在 src/third_party/blink/renderer/core/timing/performance_observer.cc 中处理性能计时
//      - 防止通过精确计时API检测获取客户端矩形所需的时间（高精度计时攻击）
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 防御基于精确像素比对的检测：
//      - 确保噪声模式不影响元素的相对布局关系
//      - 保持噪声一致性，避免每次刷新都生成不同的偏移
//      - 确保子元素矩形与父元素矩形保持合理的包含关系
//
//   2. 防御跨浏览上下文检测：
//      - 在iframe、跨窗口和弹出窗口中保持一致的噪声模式
//      - 确保不同浏览上下文中同样的元素生成一致的噪声
//
//   3. 防御基于视口变化的检测：
//      - 在滚动、缩放和窗口大小调整后保持一致的矩形变化模式
//      - 防止通过多次改变视口状态并测量矩形变化来检测指纹
//
//   4. 防御与其他API交叉验证：
//      - 确保ClientRects与Canvas、WebGL等其他可能用于测量元素位置的API返回一致的数据
//      - 处理IntersectionObserver、ResizeObserver等观察者API与ClientRects的一致性
//
//   5. 防御基于微小渲染差异的检测：
//      - 处理不同浏览器和操作系统在字体渲染、抗锯齿和亚像素渲染上的差异
//      - 为文本节点的客户端矩形应用特殊处理，这些矩形最容易反映渲染差异
//
// - 噪声注入策略：
//   * 基于元素唯一标识符（如路径或ID）和用户指纹种子生成确定性噪声
//   * 噪声应用于x、y、width、height等所有矩形属性，但保持以下约束：
//     - width和height的噪声不应导致负值
//     - 相对位置关系不应被破坏（如子元素不应超出父元素边界太多）
//     - 相邻元素的相对位置应保持不变
//   * 噪声幅度应足够小（通常<0.1px），避免视觉影响但足以改变精确测量结果
//   * 对于动画元素，确保噪声模式随动画状态平滑变化，避免突变
//
// - 综合防护策略应协调所有几何计算组件，确保：
//   * 几何一致性：所有相关的几何计算API返回一致的结果
//   * 时间一致性：在会话期间和跨会话时保持相同的噪声模式
//   * 上下文一致性：在所有浏览上下文中保持一致的行为
//   * 视觉稳定性：防护措施不应导致用户可见的布局或渲染异常

20、SSL TLS【噪音】
文件路径(已验证): src/services/network/network_context.cc
文件路径(已验证): src/services/network/public/mojom/network_context.mojom
文件路径(已验证): src/services/network/public/mojom/network_context_client.mojom
文件路径(已验证): src/net/ssl/ssl_config_service.cc
文件路径(已验证): src/net/ssl/ssl_config.cc
文件路径(已验证): src/net/ssl/ssl_config.h
文件路径(已更新): src/net/ssl/ssl_config.h
文件路径(已验证): src/net/socket/ssl_client_socket_impl.cc
文件路径(已验证): src/net/ssl/ssl_cipher_suite_names.cc
文件路径(已验证): src/net/ssl/ssl_client_session_cache.cc
文件路径(已更新): src/net/websockets/websocket_handshake_stream_base.cc
文件路径(已更新): src/net/websockets/websocket_handshake_challenge.cc
文件路径(已更新): src/net/websockets/websocket_handshake_stream_create_helper.cc
文件路径(已更新): src/net/websockets/websocket_http3_handshake_stream.cc
文件路径(已验证): src/net/cert/cert_verifier.cc
文件路径(已更新): src/net/ssl/ssl_config_service.cc
文件路径(已验证): src/net/http/transport_security_state.cc
文件路径(已更新): src/net/ssl/ssl_client_session_cache.cc

// 修改实现细节：
// - SSL/TLS 指纹技术已经变得高度复杂，远超简单的 ClientHello 检测。现代 TLS 指纹识别会分析整个握手过程中的多个特征，包括协议版本、加密套件顺序、扩展顺序和内容、密钥交换参数、会话恢复行为等。
//
// - 核心修改文件和策略：
//
//   1. TLS 配置和基础设置：
//      - 在 src/net/ssl/ssl_config.cc 和 ssl_config.h 中修改 SSLConfig 结构体的默认值和初始化
//      - 在 src/net/ssl/ssl_config_service.cc 中修改配置获取逻辑，确保使用一致的伪造配置
//      - 在 src/net/ssl/tls_version_range.h 中处理 TLS 版本范围设置，统一所有连接的 TLS 版本支持
//      - 在 src/components/ssl_config/ssl_config_service_manager.cc 中确保全局 SSL 配置管理一致
//
//   2. ClientHello 生成和加密套件管理：
//      - 在 src/net/socket/ssl_client_socket_impl.cc 中修改 ClientHello 消息的构建过程
//      - 在 src/net/ssl/ssl_cipher_suite_names.cc 中调整加密套件列表及其顺序
//      - 在 src/third_party/boringssl/src/ssl/tls13_client.cc 中处理 TLS 1.3 特有的握手行为
//      - 关键修改点是加密套件(cipher suites)的顺序和选择，这是最强的指纹信号之一
//
//   3. TLS 扩展处理：
//      - 修改 ClientHello 中的扩展列表及顺序，包括 ALPN、SNI、签名算法、椭圆曲线等
//      - 确保扩展顺序在不同会话中保持一致性，防止基于扩展排序的指纹识别
//      - 特别关注 GREASE 值的使用，这些随机值用于防止中间件假设协议的固定性
//
//   4. 握手过程和底层加密实现：
//      - 在 src/third_party/boringssl/src/ssl/handshake.cc 和 handshake_client.cc 中修改握手行为
//      - 调整密钥交换参数生成，如椭圆曲线点格式、密钥共享扩展等
//      - 统一会话票证(session tickets)和 PSK 标识符的格式和行为
//
//   5. 会话缓存和恢复行为：
//      - 在 src/net/ssl/ssl_client_session_cache.cc 中修改会话缓存和恢复逻辑
//      - 控制会话重用的模式和频率，避免通过会话恢复行为识别浏览器
//      - 调整 TLS 1.3 的 0-RTT 数据和早期数据机制，防止通过 early_data 扩展指纹
//
//   6. QUIC 协议支持：
//      - 在 src/net/third_party/quiche/src/quiche/quic/core/crypto/crypto_protocol.cc 中处理 QUIC 协议
//      - 确保 QUIC 版本协商和加密参数与标准 TLS 保持一致的伪装策略
//
//   7. 证书处理和验证：
//      - 在 src/net/cert/cert_verifier.cc 和 src/net/ssl/client_cert_store.cc 中调整证书处理
//      - 规范化客户端证书选择逻辑，避免通过证书选择行为识别用户
//
//   8. HTTP 安全策略处理：
//      - 在 src/net/http/transport_security_state.cc 中处理 HSTS 和证书透明度策略
//      - 确保安全策略执行的一致性，防止通过政策执行差异识别浏览器
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 防御 JA3/JA3S 指纹识别：
//      - 针对性调整 ClientHello 中的 TLS 版本、加密套件、扩展和扩展顺序
//      - 确保生成的 JA3 哈希值与目标浏览器模式匹配或随机化
//
//   2. 防御 AKAMAI 指纹识别：
//      - 调整握手中的计时行为和消息流顺序
//      - 规范化重协商支持和警报处理
//
//   3. 防御基于动态行为的检测：
//      - 确保握手失败后的重试行为一致
//      - 标准化密钥更新(key update)和重新握手(renegotiation)的行为
//
//   4. 防御时间侧信道分析：
//      - 调整握手计时特征，避免通过精确计时暴露底层实现差异
//      - 标准化连接建立和恢复的时间模式
//
//   5. 防御跨协议关联：
//      - 确保 HTTP/2 和 HTTP/3 的 ALPN 广告与实际协议支持一致
//      - 在 QUIC 和 TLS 之间保持一致的加密参数和版本支持
//
// - 噪声注入策略：
//   * 基于用户指纹种子生成确定性噪声，应用于：
//     - 加密套件顺序的微小变化（保持强套件优先）
//     - TLS 扩展顺序的有限调整
//     - 支持的组(supported groups)和签名算法顺序
//   * 噪声必须符合 TLS 协议规范，避免导致握手失败
//   * 噪声应当只影响指纹特征，不应降低连接安全性
//   * 噪声参数应在会话期间保持一致，避免单一会话内的变化
//
// - 综合防护策略应协调所有 TLS 组件，确保：
//   * 协议一致性：所有 TLS 设置在各连接间保持一致
//   * 安全保障：噪声注入不会降低 TLS 连接的安全性
//   * 性能维持：防护措施不会显著影响连接建立时间
//   * 稳定兼容：修改的握手行为与大多数服务器兼容

21、硬件并发数【真实 自定义（2 4 6 8 12 16 20 24）】
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_concurrent_hardware.cc
文件路径(已验证): src/base/system/sys_info.cc
文件路径(已验证): src/third_party/blink/renderer/core/workers/worker_navigator.cc

// 修改实现细节：
// - 硬件并发数通常指 CPU 的核心数或逻辑处理器数量，通过 navigator.hardwareConcurrency 属性暴露给 JavaScript。
// - 修改的核心在于 src/base/system/sys_info.cc。这个文件提供了跨平台获取系统信息的函数，包括获取 CPU 核心数。需要修改 sys_info.cc 中获取硬件并发数的函数，拦截系统调用，并返回伪造的数值。
// - src/third_party/blink/renderer/core/frame/navigator_concurrent_hardware.cc 实现了 navigator.hardwareConcurrency 属性，它会调用 base::SysInfo::NumberOfProcessors()。确保修改 sys_info.cc 后，能够正确获取到伪造的值并暴露给 JavaScript。
// - src/third_party/blink/renderer/core/workers/worker_navigator.cc 是 Web Worker 中 navigator 对象的实现，也会获取硬件并发数，修改 sys_info.cc 会影响到 Worker。

22、硬盘数量【真实 自定义（1 2 3 4 5 6）】
文件路径(已验证): src/content/browser/site_instance_impl.cc
文件路径(已验证): src/base/files/file_util.h
文件路径(已验证): src/base/files/file_util.cc
文件路径(已验证): src/base/files/file_util_win.cc
文件路径(已验证): src/base/files/file_util_posix.cc

// 修改实现细节：
// - 硬盘数量通常指系统可用的逻辑驱动器或文件系统数量。Chromium 通过 base::files 提供的跨平台文件工具函数来获取这些信息。
// - 修改的核心在于 base/files 目录下平台相关的实现文件（file_util_win.cc 和 file_util_posix.cc）。这些文件封装了底层操作系统 API 调用，用于枚举或获取驱动器/文件系统信息。
// - 需要在这些平台相关的实现文件中找到负责获取驱动器列表或数量的函数，并修改其返回结果，使其返回伪造的硬盘数量。
// - base/files/file_util.cc 提供了通用的接口，它会根据平台调用具体的实现。修改底层平台实现是更直接和有效的方式。
// - src/content/browser/site_instance_impl.cc 等文件可能通过 base::files 的接口间接获取硬盘数量，因此修改底层实现会影响到这些调用方。

23、设备内存【真实 自定义（4 8 16 32 ）】
文件路径(已验证): src/content/browser/site_instance_impl.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_device_memory.cc
文件路径(已验证): src/base/system/sys_info.cc
文件路径(已更新): src/third_party/blink/renderer/modules/webassembly/wasm_module.cc
文件路径(已更新): src/third_party/blink/renderer/modules/webassembly/wasm_module.cc
文件路径(已验证): src/third_party/blink/renderer/core/workers/worker_thread.cc
文件路径(已验证): src/third_party/blink/renderer/platform/wtf/allocator/partitions.cc
文件路径(已验证): src/content/browser/renderer_host/render_process_host_impl.cc
文件路径(已更新): src/courgette/memory_monitor.cc
文件路径(已更新): src/third_party/blink/renderer/core/typed_arrays/dom_shared_array_buffer.cc
文件路径(已验证): src/third_party/blink/renderer/core/timing/performance.cc
文件路径(已更新): src/third_party/blink/renderer/core/timing/performance.cc
文件路径(已更新): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(已更新): src/content/browser/loader/resource_scheduler_browsertest.cc
文件路径(已更新): src/content/browser/memory_pressure/user_level_memory_pressure_signal_generator.cc

// 修改实现细节：
// - 设备内存指纹已经超越简单的 navigator.deviceMemory API 检测，现代指纹技术通过多种方法推断设备内存，包括性能测试、内存分配上限测试和行为分析等。
// 
// - 核心修改文件和策略：
// 
//   1. navigator.deviceMemory API 基础防护：
//      - 在 src/third_party/blink/renderer/core/frame/navigator_device_memory.cc 中修改 NavigatorDeviceMemory::deviceMemory() 方法
//      - 在 src/base/system/sys_info.cc 中修改 AmountOfPhysicalMemory() 等获取内存信息的函数
//      - 在 src/third_party/blink/renderer/core/frame/navigator_base.cc 中确保其他相关 Navigator 接口也返回一致的伪造值
//      - 此为最基本的保护，但远远不足以应对现代指纹技术
// 
//   2. WebAssembly 内存分配防护：
//      - 在 src/third_party/blink/renderer/modules/webassembly/wasm_memory.cc 中修改 WebAssembly.Memory 构造函数
//      - 在 src/third_party/blink/renderer/modules/webassembly/wasm_module_builder.cc 中调整内存分配上限检查
//      - 确保大内存分配请求不会因真实内存限制而失败，同时小内存分配行为保持正常
//      - 防止网站通过尝试分配大量 WebAssembly 内存来检测设备内存上限
// 
//   3. 工作线程和共享内存限制：
//      - 在 src/third_party/blink/renderer/core/workers/worker_thread.cc 中统一工作线程的内存限制
//      - 在 src/third_party/blink/renderer/core/typed_arrays/shared_array_buffer.cc 中调整 SharedArrayBuffer 的分配限制
//      - 防止通过多线程和共享内存分配测试设备内存容量
// 
//   4. 内存分配和分区：
//      - 在 src/third_party/blink/renderer/platform/wtf/allocator/partitions.cc 中修改内存分区和分配行为
//      - 确保大内存请求的处理方式一致，防止通过内存分配行为推断设备内存
//      - 调整内存分配失败或OOM（内存不足）的触发阈值，使其与伪造的设备内存值一致
// 
//   5. 渲染进程内存限制：
//      - 在 src/content/browser/renderer_host/render_process_host_impl.cc 中统一渲染进程的内存限制
//      - 确保这些限制与伪造的设备内存总量保持合理比例
//      - 防止通过分析多个标签页的内存限制来推断总内存
// 
//   6. 性能计时和内存压力：
//      - 在 src/third_party/blink/renderer/core/timing/performance.cc 和 performance_memory.cc 中处理性能内存指标
//      - 在 src/content/browser/memory/memory_monitor.cc 和 memory_pressure_controller.cc 中调整内存监控行为
//      - 防止通过性能API和内存压力事件推断设备内存
//      - 调整内存密集型操作的计时行为，防止基于执行时间的内存容量推断
// 
//   7. 资源调度和内存平衡：
//      - 在 src/content/browser/renderer_host/resource_scheduler.cc 中调整资源调度策略
//      - 确保在不同内存负载下的资源加载行为一致
//      - 防止通过资源加载优先级和节流行为推断设备内存
// 
// - 针对最新指纹检测技术的特定防护措施：
// 
//   1. 防御崩溃测试检测：
//      - 调整OOM处理行为，使其在伪造的内存限制下一致触发
//      - 确保大内存分配不会出现与伪造值不一致的崩溃行为
// 
//   2. 防御性能测试检测：
//      - 标准化内存密集型操作的执行时间
//      - 模拟特定内存容量下的GC（垃圾收集）频率和时间
//      - 调整内存压力事件的触发阈值和频率
// 
//   3. 防御多标签页测试：
//      - 确保多个标签页之间的内存分配行为一致
//      - 防止通过打开多个标签页并测量性能下降来推断内存容量
// 
//   4. 防御分配上限检测：
//      - 在各种内存分配API中实现一致的上限行为
//      - 确保数组、Buffer、WebAssembly和其他可能用于测试内存上限的对象表现一致
// 
//   5. 防御细粒度行为分析：
//      - 调整GC触发频率和持续时间
//      - 标准化内存碎片整理和压缩行为
//      - 确保缓存淘汰策略与伪造的内存限制一致
// 
// - 自定义内存值实现策略：
//   * 当用户选择自定义内存值（如4GB、8GB、16GB、32GB）时：
//     - 所有暴露内存信息的API都返回一致的伪造值
//     - 内存分配限制和OOM行为根据伪造值进行相应调整
//     - 性能特征（如GC频率、执行时间）也应与所选内存值相符
//     - 确保内存压力事件和资源调度行为与伪造的内存值保持一致
// 
// - 综合防护策略应协调所有内存相关组件，确保：
//   * 数据一致性：所有内存相关API返回的信息互相一致
//   * 行为一致性：内存分配、GC、压力事件等行为与伪造的内存值相符
//   * 性能一致性：内存密集型操作的执行时间符合伪造的设备配置
//   * 兼容性维持：防护措施不会破坏网站的正常功能

24、电池【噪音（噪音要随机充电状态 和 剩余电量） 真实】
文件路径(已验证): src/third_party/blink/renderer/modules/battery/battery_manager.cc
文件路径(已验证): src/services/device/battery/battery_monitor_impl.cc
文件路径(已验证): src/services/device/public/mojom/battery_status.mojom
文件路径(已验证): src/third_party/blink/renderer/modules/battery/battery_manager.h
文件路径(已验证): src/services/device/battery/battery_status_service.cc
文件路径(未找到): src/services/device/battery/battery_status_manager.cc
文件路径(已验证): src/services/device/battery/battery_status_manager.h
文件路径(已验证): src/content/browser/browser_interface_binders.cc
文件路径(未找到): src/services/device/battery/win/win_battery_monitor.cc
文件路径(未找到): src/services/device/battery/mac/mac_battery_monitor.mm
文件路径(未找到): src/services/device/battery/linux/upower_battery_monitor.cc
文件路径(未找到): src/services/device/battery/android/android_battery_monitor.cc
文件路径(未找到): src/services/device/battery/fake_battery_monitor.cc
文件路径(未找到): src/services/device/battery/fake_battery_monitor.h
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(已验证): src/content/browser/renderer_host/render_process_host_impl.cc

// 修改实现细节：
// - 电池指纹保护需要应对现代指纹检测技术，这些技术不仅检测静态电池参数，还会分析电池状态随时间变化的模式和一致性。
//
// - 核心修改文件和策略：
//
//   1. Blink层JavaScript接口防护：
//      - 在 src/third_party/blink/renderer/modules/battery/battery_manager.cc 中修改 BatteryManager 的实现
//      - 在 src/third_party/blink/renderer/modules/battery/battery_manager.h 中定义适当的私有成员变量存储伪造状态
//      - 在 src/third_party/blink/renderer/core/frame/navigator.cc 中确保 navigator.getBattery() 返回伪造的管理器实例
//      - 重点处理 getBattery() Promise 的解析过程，确保异步行为与真实设备一致
//
//   2. 电池服务层防护：
//      - 在 src/services/device/battery/battery_monitor_impl.cc 中拦截真实电池状态查询
//      - 在 src/services/device/battery/battery_status_service.cc 中修改服务实现，返回伪造的电池状态
//      - 在 src/services/device/battery/battery_status_manager.cc 中控制状态更新的频率和模式
//      - 利用 src/services/device/battery/fake_battery_monitor.cc 和 fake_battery_monitor.h 实现自定义电池模拟
//
//   3. 平台特定实现防护：
//      - 在平台特定文件(win_battery_monitor.cc, mac_battery_monitor.mm, upower_battery_monitor.cc, android_battery_monitor.cc)中
//        拦截底层系统API调用，确保不同平台上行为一致
//      - 处理不同平台的电池报告特性差异，统一电池状态的表现形式
//      - 确保在无电池设备(如台式机)上的行为也与有电池设备保持一致性
//
//   4. 进程间通信防护：
//      - 在 src/content/browser/browser_interface_binders.cc 中处理电池服务绑定，确保正确路由到伪造服务
//      - 在 src/content/browser/renderer_host/render_process_host_impl.cc 中确保电池状态更新消息被正确处理
//      - 确保通过Mojo接口传递的电池状态数据一致性
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 防御电池状态变化一致性检测：
//      - 实现物理上合理的充放电曲线模型，避免线性或随机变化
//      - 确保电池电量level(0.0-1.0)的变化率符合真实电池特性：
//        * 充电时，接近空电量时变化较快，接近满电量时变化较慢
//        * 放电时，中等电量区域变化较快，低电量区域变化较慢
//      - 保持充电状态(charging)与电量变化率之间的逻辑一致性
//
//   2. 防御充放电时间合理性检测：
//      - 确保chargingTime和dischargingTime与当前电量水平和充电状态保持合理关系
//      - 在电池接近充满时，chargingTime应逐渐减小并接近0
//      - 在电池电量较高时，dischargingTime应较大；电量较低时，应较小
//      - 当电池状态发生变化时(如开始充电)，确保时间估计值的突变符合逻辑
//
//   3. 防御事件监听检测：
//      - 在电池状态变化时正确触发'chargingchange'、'levelchange'、'chargingtimechange'和'dischargingtimechange'事件
//      - 确保事件触发的频率和时机符合真实设备特性，避免过于频繁或规律的事件触发
//      - 处理事件处理程序添加和移除的逻辑，确保addEventListener和removeEventListener正常工作
//
//   4. 防御多标签页一致性检测：
//      - 确保同一浏览器不同标签页中的电池状态保持同步
//      - 在浏览器会话期间维持一致的电池状态变化模式
//      - 防止通过打开多个标签页并比较电池状态来检测不一致
//
//   5. 防御时间序列分析：
//      - 实现基于时间的电池状态演变模型，确保长时间监测下的状态变化符合物理规律
//      - 避免使用简单的随机数生成器，可能被统计分析识别
//      - 对于长时间运行的页面，模拟真实的电池周期(充电-满电-放电-低电量-充电)
//
//   6. 防御设备特性交叉验证：
//      - 确保电池状态与其他设备特性(如移动设备vs台式机)保持逻辑一致性
//      - 在移动设备配置下提供更活跃的电池状态变化
//      - 在台式机配置下可以模拟"始终充电"或"无电池"状态
//
// - 噪音实现策略：
//   * 基于用户指纹种子创建确定性但看似随机的电池行为模型
//   * 电池参数噪音添加遵循以下原则：
//     - 充电状态(charging)：在特定时间点模拟插拔充电器，而不是完全随机切换
//     - 电量水平(level)：在合理范围内(0.05-0.95)波动，避免极端值，遵循物理充放电曲线
//     - 充电时间(chargingTime)：与当前电量呈负相关，接近满电时接近0
//     - 放电时间(dischargingTime)：与当前电量呈正相关，低电量时接近0
//   * 状态更新频率控制：
//     - 避免过于频繁的更新(如每秒多次)，通常每30-120秒更新一次较为合理
//     - 充电状态变化(插入或拔出充电器)应该是相对罕见的事件
//   * 在会话期间保持一致的变化模式，避免重新加载页面后出现不合理的状态跳变
//
// - 实现"真实"模式的策略：
//   * 直接透传系统实际电池状态，但仍需处理无电池设备的情况
//   * 在无电池设备上可以选择报告"无电池"(navigator.getBattery()仍然解析，但所有事件都不触发)
//     或模拟一个永久充电状态(charging=true, level=1.0)
//
// - 防护实现需考虑的边缘情况：
//   * 系统休眠和唤醒后电池状态的合理性
//   * 长时间运行页面的电池状态演变
//   * 不同浏览上下文(iframe、worker等)中的电池状态一致性
//   * 设备充电速度的差异(快充vs标准充电)
//   * 低电量模式对放电时间的影响
//
// - 整体实现应确保：
//   * 电池状态的物理合理性：所有参数之间保持逻辑关系
//   * 时间一致性：在会话期间维持合理的状态变化
//   * 事件处理的准确性：在适当时机触发正确的事件
//   * 跨平台行为一致性：不同操作系统下表现相似
//   * 性能影响最小化：避免频繁更新导致的性能问题

25、端口扫描保护【开启保护 关闭保护】
文件路径(已验证): src/services/network/network_context.cc
文件路径(已验证): src/net/base/port_util.cc
文件路径(已验证): src/net/base/port_util.h
文件路径(已验证): src/net/socket/client_socket_pool_manager.cc
文件路径(已验证): src/net/socket/tcp_socket_win.cc
文件路径(已验证): src/net/socket/tcp_socket_posix.cc
文件路径(已验证): src/services/network/public/mojom/network_service.mojom
文件路径(已验证): src/services/network/socket_factory.cc
文件路径(已验证): src/services/network/websocket_factory.cc
文件路径(已验证): src/services/network/public/mojom/websocket.mojom
文件路径(已验证): src/services/network/restricted_cookie_manager.cc
文件路径(未找到): src/third_party/blink/renderer/modules/websockets/websocket.cc
文件路径(未找到): src/third_party/blink/renderer/modules/websockets/websocket_channel.cc
文件路径(已验证): src/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc
文件路径(已验证): src/third_party/blink/renderer/core/fetch/fetch_request_data.cc
文件路径(未找到): src/third_party/blink/renderer/core/fetch/body.cc
文件路径(未找到): src/net/dns/host_resolver_manager.cc
文件路径(未找到): src/third_party/webrtc/p2p/base/port_allocator.cc
文件路径(未找到): src/third_party/webrtc/p2p/client/basic_port_allocator.cc
文件路径(未找到): src/net/quic/quic_stream_factory.cc
文件路径(未找到): src/content/browser/content_security_policy/content_security_policy_context.cc
文件路径(已验证): src/content/browser/renderer_host/render_process_host_impl.cc
文件路径(已验证): src/content/browser/browser_interface_binders.cc

// 修改实现细节：
// - 现代端口扫描保护需要应对复杂多样的Web API和高级扫描技术，不再局限于传统的TCP连接尝试。
//
// - 核心修改文件和策略：
//
//   1. 基础网络连接保护：
//      - 在 src/net/base/port_util.cc 和 port_util.h 中定义受限端口范围和检查函数
//      - 在 src/net/socket/tcp_socket_win.cc 和 tcp_socket_posix.cc 中实现底层平台相关的连接拦截
//      - 在 src/net/socket/client_socket_pool_manager.cc 中实现高层连接池的安全检查
//      - 定义统一的端口安全策略，包括常见特权端口(0-1023)、内网特殊服务端口和已知易受攻击的端口
//
//   2. 现代Web API保护：
//      - 在 src/third_party/blink/renderer/modules/websockets/websocket.cc 和 websocket_channel.cc 中防止WebSocket被用于端口扫描
//      - 在 src/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc 中拦截XHR的可疑连接尝试
//      - 在 src/third_party/blink/renderer/core/fetch/fetch_request_data.cc 和 body.cc 中处理Fetch API的端口访问控制
//      - 确保所有这些高级API在尝试连接时经过相同的端口检查逻辑
//
//   3. WebRTC和P2P通信保护：
//      - 在 src/third_party/webrtc/p2p/base/port_allocator.cc 和 basic_port_allocator.cc 中限制ICE候选地址的端口范围
//      - 防止WebRTC的STUN/TURN协议被滥用于端口扫描，特别是针对内网地址
//      - 确保P2P连接过程中生成的候选地址不会泄露受保护的端口信息
//
//   4. 新一代协议保护：
//      - 在 src/net/quic/quic_stream_factory.cc 中处理QUIC协议的端口访问控制
//      - 确保HTTP/3等新协议不会绕过现有的端口扫描保护
//
//   5. 安全策略和服务层保护：
//      - 在 src/content/browser/content_security_policy/content_security_policy_context.cc 中通过CSP增强网络连接控制
//      - 在 src/services/network/network_context.cc 中实现网络服务级别的安全策略
//      - 在 src/services/network/socket_factory.cc 和 websocket_factory.cc 中集中处理socket创建请求
//      - 在 src/services/network/restricted_cookie_manager.cc 中防止通过cookie操作间接推断端口状态
//
//   6. 进程间通信和接口绑定保护：
//      - 在 src/content/browser/renderer_host/render_process_host_impl.cc 中控制渲染进程的网络访问权限
//      - 在 src/content/browser/browser_interface_binders.cc 中确保安全地绑定网络相关服务
//      - 通过 src/services/network/public/mojom/network_service.mojom 和 websocket.mojom 定义的接口强制执行安全策略
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 防御高级时序攻击：
//      - 实现随机化的连接延迟，防止攻击者通过精确计时区分开放/关闭端口
//      - 对连接失败行为进行标准化，使各类失败原因(端口关闭、防火墙阻断、端口保护等)的响应时间和错误消息一致
//      - 防止通过performance.now()等高精度计时API测量连接尝试的精确时间
//
//   2. 防御WebSocket和EventSource探测：
//      - 标准化WebSocket连接失败的行为，无论端口是开放还是关闭
//      - 确保EventSource的错误处理不会泄露端口状态信息
//      - 处理WebSocket的readyState和onclose事件，避免通过这些状态和事件推断端口状态
//
//   3. 防御间接探测技术：
//      - 防止通过缓存计时攻击间接推断端口状态
//      - 防止通过跨站请求和CORS错误信息推断端口状态
//      - 防止通过Service Worker的fetch事件处理程序进行后台端口扫描
//
//   4. 防御基于DNS的端口推断：
//      - 在 src/net/dns/host_resolver_manager.cc 中实现对DNS请求的控制
//      - 防止通过DNS解析时间差异间接推断端口状态
//      - 统一处理DNS解析失败和连接失败的行为
//
//   5. 防御内网扫描特定技术：
//      - 对内网IP范围(如192.168.x.x, 10.x.x.x等)实施更严格的端口访问控制
//      - 特别保护常见的内网服务端口，如路由器管理界面(80/443/8080)、打印机端口、共享服务等
//      - 防止通过WebRTC ICE候选地址泄露内网IP和开放端口信息
//
// - 保护模式实现策略：
//   * "开启保护"模式实现：
//     - 对所有网络连接请求进行严格的端口安全检查
//     - 对受限端口的连接请求返回标准化的错误，不透露真实原因
//     - 对可疑的扫描行为(短时间内多次尝试连接不同端口)实施节流或临时阻断
//     - 在安全日志中记录可疑的端口扫描活动，但不向页面暴露这些信息
//
//   * "关闭保护"模式实现：
//     - 只执行浏览器默认的最低安全检查(如特权端口限制)
//     - 不对连接尝试施加额外的限制或延迟
//     - 不干预WebRTC、WebSocket等API的正常连接尝试
//     - 注意：即使在关闭保护模式下，仍应维持基本安全底线，防止最危险的攻击
//
// - 实现需要注意的边缘情况：
//   * 处理合法应用需要访问非标准端口的情况(如开发环境中的本地服务)
//   * 确保VPN和代理环境下的端口扫描保护正常工作
//   * 处理WebView和扩展中的端口访问控制
//   * 确保不干扰正常的Web应用功能，特别是使用WebSocket和WebRTC的应用
//   * 防止保护机制本身成为新的指纹向量(如通过测试特定端口的连接行为识别保护实现)
//
// - 与其他指纹保护功能的协调：
//   * 与WebRTC IP地址保护(指纹13)协同工作，确保政策一致
//   * 与代理指纹保护(指纹40)协调，确保代理环境下的端口保护正常工作
//   * 与DNS系统指纹保护(指纹41)配合，防止通过DNS相关技术绕过端口保护
//   * 与CSP(内容安全策略)相关设置保持一致，避免策略冲突

26、禁用控制台输出【开启 关闭】
禁用console.log等方法输出信息，防止某些网站通过console作为检测项
文件路径(已验证): src/third_party/blink/renderer/core/inspector/console_message.cc
文件路径(未找到): src/third_party/blink/renderer/core/inspector/inspector_console_agent.cc
文件路径(未找到): src/third_party/blink/renderer/core/frame/console.cc
文件路径(未找到): src/third_party/blink/renderer/core/frame/global_scope.cc
文件路径(未找到): src/third_party/blink/renderer/bindings/core/v8/v8_console.cc
文件路径(已验证): src/third_party/blink/renderer/core/workers/worker_global_scope.cc
文件路径(已验证): src/third_party/blink/renderer/core/execution_context/execution_context.cc
文件路径(未找到): src/content/renderer/devtools/devtools_agent.cc
文件路径(未找到): src/v8/src/debug/debug.cc
文件路径(已验证): src/third_party/blink/renderer/platform/bindings/exception_state.cc
文件路径(已验证): src/third_party/blink/renderer/core/inspector/inspector_log_agent.cc
文件路径(已验证): src/third_party/blink/renderer/core/inspector/devtools_session.cc
文件路径(已验证): src/third_party/blink/renderer/core/inspector/main_thread_debugger.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/dom_window.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/performance_monitor.cc
文件路径(已验证): src/third_party/blink/renderer/core/timing/performance.cc
文件路径(已验证): src/content/renderer/render_thread_impl.cc

// 修改实现细节：
// - 现代网站使用多种控制台相关技术进行指纹识别和自动化检测，需要全面防护策略。
//
// - 核心修改文件和策略：
//
//   1. 主要控制台接口防护：
//      - 在 src/third_party/blink/renderer/core/frame/console.cc 中修改 Console 类的实现
//      - 重写所有控制台方法(log, info, warn, error, debug, trace, dir, dirxml, table, clear等)
//      - 使用一致性策略：在"开启"保护模式下，使这些方法成为空操作，但保留方法本身以避免报错
//      - 在 src/third_party/blink/renderer/bindings/core/v8/v8_console.cc 中处理V8绑定层面的控制台接口
//
//   2. 消息处理和传递防护：
//      - 在 src/third_party/blink/renderer/core/inspector/console_message.cc 中修改消息创建和处理
//      - 在 src/third_party/blink/renderer/core/inspector/inspector_console_agent.cc 中拦截消息发送
//      - 确保不仅拦截直接console调用，还包括内部生成的警告、错误和调试信息
//      - 在 src/third_party/blink/renderer/core/inspector/inspector_log_agent.cc 中处理网络和存储日志
//
//   3. 全局作用域和执行上下文防护：
//      - 在 src/third_party/blink/renderer/core/frame/global_scope.cc 中处理全局console对象的定义
//      - 在 src/third_party/blink/renderer/core/execution_context/execution_context.cc 中控制执行上下文的日志行为
//      - 在 src/third_party/blink/renderer/core/frame/dom_window.cc 中处理window环境的console对象
//      - 确保在所有JavaScript执行环境中保持一致的控制台行为
//
//   4. Worker环境防护：
//      - 在 src/third_party/blink/renderer/core/workers/worker_global_scope.cc 中处理Worker中的控制台
//      - 确保Web Worker、Service Worker和其他工作线程中的控制台输出也受到控制
//      - 防止通过Worker环境绕过主线程的控制台限制
//
//   5. 调试工具和会话防护：
//      - 在 src/content/renderer/devtools/devtools_agent.cc 中处理DevTools代理
//      - 在 src/third_party/blink/renderer/core/inspector/devtools_session.cc 中控制调试会话
//      - 在 src/third_party/blink/renderer/core/inspector/main_thread_debugger.cc 中处理主线程调试器
//      - 防止远程调试功能被用于检测控制台拦截状态
//
//   6. 异常和错误处理防护：
//      - 在 src/third_party/blink/renderer/platform/bindings/exception_state.cc 中处理异常状态
//      - 在 src/v8/src/debug/debug.cc 中修改V8调试功能的行为
//      - 确保JavaScript异常和错误不会绕过控制台保护，泄露敏感信息
//
//   7. 性能和计时功能防护：
//      - 在 src/third_party/blink/renderer/core/frame/performance_monitor.cc 中处理性能监控
//      - 在 src/third_party/blink/renderer/core/timing/performance.cc 中处理与console.time相关的功能
//      - 防止通过性能API间接检测控制台功能
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 防御控制台对象修改检测：
//      - 保持console对象的标准属性和方法完整，只修改其行为
//      - 防止网站通过检查console对象的结构、原型链或属性描述符发现异常
//      - 确保Object.getOwnPropertyDescriptor(console, 'log')等操作返回标准结果
//
//   2. 防御功能性测试检测：
//      - 处理console.log.toString()的返回值，确保其看起来是原生函数
//      - 确保Function.prototype.apply和call方法用于console函数时行为一致
//      - 防止通过测试控制台输出捕获功能(如覆盖console.log后测试原始功能是否可恢复)来检测
//
//   3. 防御错误和异常分析：
//      - 确保控制台错误和警告的静默处理不会影响正常的错误传播
//      - 处理try/catch块中控制台使用的特殊情况
//      - 确保window.onerror和window.addEventListener('error',...)事件处理正常但不泄露信息
//
//   4. 防御间接控制台检测：
//      - 处理对console.memory属性的访问，返回合理的内存使用数据
//      - 处理控制台样式(%c)和格式化功能，确保它们被正确模拟或禁用
//      - 防止通过监测其他API(如document.title或DOM变更)间接检测控制台输出
//
//   5. 防御高级调试功能检测：
//      - 处理console.profile/profileEnd等性能分析功能
//      - 控制console.count和console.countReset的行为
//      - 处理console.assert、console.group/groupEnd等结构化功能
//      - 确保console.timeStamp与性能时间线的交互正常但不暴露信息
//
//   6. 防御新控制台API检测：
//      - 处理较新的API如console.table、console.markTimeline等
//      - 跟踪并适配Chrome DevTools添加的新控制台功能
//      - 保持与最新浏览器版本的控制台行为一致性
//
// - 保护模式实现策略：
//   * "开启"保护模式实现：
//     - 使所有console方法保持存在但成为无操作函数
//     - 阻止消息传递到DevTools前端，但保持内部消息流
//     - 确保返回undefined等默认值，保持与原始API一致
//     - 处理特殊返回值的方法(如console.timeLog返回时间差值)
//     - 实现隐蔽性措施，避免保护本身被检测
//
//   * "关闭"保护模式实现：
//     - 恢复所有控制台功能的原始行为
//     - 确保开启和关闭模式之间的无缝切换
//     - 在会话期间保持一致，避免刷新页面时行为变化
//
// - 实现需要注意的特殊情况：
//   * 处理嵌套iframe中的控制台行为
//   * 确保不干扰开发人员在实际开发中使用控制台的能力
//   * 处理特定网站对控制台的依赖(如某些需要控制台输出的调试网站)
//   * 确保与其他指纹防护功能(如WebDriver检测、远程调试检测)的一致性
//   * 处理扩展和内容脚本中的控制台使用
//   * 考虑对资源加载错误和CORS错误等自动控制台输出的处理
//
// - 综合防护原则：
//   * 隐蔽性：保护措施本身不应成为可检测的特征
//   * 一致性：在所有执行环境中保持一致的行为
//   * 完整性：处理控制台API的所有方面，不留检测漏洞
//   * 灵活性：允许在需要时轻松启用/禁用保护
//   * 兼容性：确保不破坏依赖控制台的合法网站功能

27、Do Not Track【开启 关闭】
文件路径(已验证): src/components/privacy_sandbox/tracking_protection_settings.cc
文件路径(已验证): src/net/url_request/url_request.cc
文件路径(已验证): src/net/http/http_request_headers.cc
文件路径(已验证): src/chrome/browser/net/system_network_context_manager.cc
文件路径(已验证): src/components/content_settings/core/browser/content_settings_registry.cc
文件路径(已验证): src/content/browser/renderer_host/render_process_host_impl.cc
文件路径(已验证): src/services/network/public/cpp/features.cc
文件路径(未找到): src/third_party/blink/public/common/features.cc

// 修改实现细节：
// - "Do Not Track"（DNT）是一个浏览器设置，当启用时，浏览器会在 HTTP 请求头中发送一个特殊的信号（DNT: 1），向网站表明用户不希望被追踪。
// - 核心修改在于控制是否在 HTTP 请求头中发送 DNT: 1 信号。
// - 修改 src/components/privacy_sandbox/tracking_protection_settings.cc 中的 IsDoNotTrackEnabled() 方法，使其根据指纹保护模式决定是否启用 DNT。
// - 修改 src/net/url_request/url_request.cc 文件，在 URLRequestHttpJob::AddExtraHeaders() 方法中根据 DNT 设置添加或移除 DNT 头部。
// - 确保 src/net/http/http_request_headers.cc 中 HTTP 请求头的处理能够正确添加或跳过 DNT 头部。
// - 修改 src/chrome/browser/net/system_network_context_manager.cc 确保网络上下文正确配置 DNT 设置。
// - 在 src/components/content_settings/core/browser/content_settings_registry.cc 中注册和处理 DNT 相关的内容设置。
// - 在 src/content/browser/renderer_host/render_process_host_impl.cc 确保进程间通信正确传递 DNT 设置。
//
// - 特别注意的实现问题：
//   * 不同窗口和会话之间的 DNT 设置一致性
//   * 确保 DNT 设置在浏览器重启后保持不变
//   * 处理跨域请求中的 DNT 头部一致性
//   * 确保所有网络请求（包括XHR、Fetch、图像加载等）都正确应用 DNT 设置
//   * 在隐私浏览模式下 DNT 设置的特殊处理
//
// - 防御最新指纹检测技术的特定措施：
//   * 确保 DNT 设置在所有请求中保持一致，避免通过不同请求的 DNT 不一致进行检测
//   * 处理 JavaScript 可能通过间接方式检测 DNT 设置的情况
//   * 确保 DNT 设置与其他隐私设置（如第三方 Cookie 阻止、隐私浏览模式等）的逻辑关系合理
//   * 防止通过网络请求计时差异检测 DNT 状态
//   * 确保子资源和内嵌内容的 DNT 头部与主文档一致
//
// - 实现"开启/关闭"功能：
//   * "开启"模式：在所有 HTTP 请求中添加 "DNT: 1" 头部
//   * "关闭"模式：不添加任何 DNT 相关头部
//   * 通过 fingerprint_protection::FingerprintController 获取当前窗口的指纹模式，根据模式决定 DNT 行为
//   * 在指纹保护系统的 JSON 配置文件中添加 DNT 设置选项
//
// - 兼容性考虑：
//   * 确保修改不影响其他隐私设置功能
//   * 处理可能依赖于 DNT 信号的网站兼容性问题
//   * 考虑新版浏览器中 Global Privacy Control (GPC) 与 DNT 的关系

// 示例修改代码片段：
// 在 components/privacy_sandbox/tracking_protection_settings.cc 中：
/*
bool TrackingProtectionSettings::IsDoNotTrackEnabled() const {
  // Check fingerprint controller for Do Not Track setting
  auto* controller = fingerprint_protection::FingerprintController::GetInstance();
  if (controller && controller->IsActive()) {
    uint64_t window_id = controller->GetCurrentWindowId();
    fingerprint_protection::FingerprintMode mode = controller->GetModeForWindow(window_id);
    
    // If using REAL fingerprint mode, use the user's actual preference
    if (mode != fingerprint_protection::FingerprintMode::REAL) {
      // For CUSTOM mode, check the specific DNT setting
      if (mode == fingerprint_protection::FingerprintMode::CUSTOM) {
        return controller->IsDNTEnabled(window_id);
      }
      // For other modes, use the fingerprint profile's consistent setting
      std::string domain = controller->GetCurrentDomain();
      return controller->GetRandomBoolForWindow(
          window_id, domain, "dnt_enabled", 0.5);
    }
  }
  
  // Fall back to the user's actual preference if fingerprint protection isn't active
  return pref_service_->GetBoolean(prefs::kEnableDoNotTrack);
}
*/

28、User-Agent (用户代理)【自定义 真实】
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(已验证): src/net/http/http_request_headers.cc
文件路径(已验证): src/content/common/user_agent.cc
文件路径(已验证): src/base/version_info/version_info.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_id.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_ua_data.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_ua_data.h
文件路径(未找到): src/content/browser/user_agent_client.cc
文件路径(未找到): src/services/network/public/cpp/user_agent.cc
文件路径(已验证): src/content/public/common/content_switches.cc
文件路径(未找到): src/third_party/blink/renderer/platform/network/http_names.cc
文件路径(已验证): src/third_party/blink/renderer/core/fetch/headers.cc
文件路径(未找到): src/chrome/browser/content_settings/request_header_manager.cc
文件路径(未找到): src/net/http/structured_headers.cc
文件路径(已验证): src/services/network/url_loader.cc
文件路径(未找到): src/services/network/public/mojom/user_agent_metadata.mojom
文件路径(未找到): src/third_party/blink/renderer/core/executed_script/executed_script_permissions.cc
文件路径(已验证): src/third_party/blink/common/client_hints/client_hints.cc
文件路径(未找到): src/third_party/blink/common/client_hints/client_hints.h
文件路径(已验证): src/content/browser/renderer_host/render_process_host_impl.cc

// 修改实现细节：
// - 现代User-Agent指纹防护需要应对复杂的检测技术，不仅涉及传统的UA字符串，还包括Client Hints和各种间接检测方法。
//
// - 核心修改文件和策略：
//
//   1. 传统User-Agent字符串防护：
//      - 在 src/content/common/user_agent.cc 中修改UA字符串生成逻辑
//      - 在 src/third_party/blink/renderer/core/frame/navigator.cc 和 navigator_id.cc 中处理navigator.userAgent属性
//      - 在 src/net/http/http_request_headers.cc 中确保HTTP请求头中使用相同的伪造UA
//      - 在 src/base/version_info/version_info.cc 中控制版本信息，确保与伪造UA一致
//      - 确保生成的UA字符串格式符合标准，包含所有必要组件（浏览器名称/版本、平台、操作系统等）
//
//   2. 现代User-Agent Client Hints防护：
//      - 在 src/third_party/blink/renderer/core/frame/navigator_ua_data.cc 中修改navigator.userAgentData实现
//      - 在 src/third_party/blink/common/client_hints/client_hints.cc 中处理UA相关的Client Hints政策
//      - 在 src/services/network/public/mojom/user_agent_metadata.mojom 中调整UA元数据结构
//      - 处理包括Sec-CH-UA、Sec-CH-UA-Platform、Sec-CH-UA-Mobile等现代UA头部
//      - 确保低熵和高熵信息（浏览器、平台、架构、位数、移动标志等）与伪造UA保持一致
//
//   3. HTTP请求头与网络层防护：
//      - 在 src/services/network/url_loader.cc 中确保所有网络请求使用一致的UA
//      - 在 src/third_party/blink/renderer/platform/network/http_names.cc 中处理UA相关的HTTP头名称
//      - 在 src/third_party/blink/renderer/core/fetch/headers.cc 中处理Fetch API的UA头部设置
//      - 在 src/chrome/browser/content_settings/request_header_manager.cc 中处理内容设置对UA的影响
//      - 在 src/net/http/structured_headers.cc 中处理结构化UA头部格式
//
//   4. 浏览器进程间通信与一致性防护：
//      - 在 src/content/browser/user_agent_client.cc 中确保浏览器进程中UA一致
//      - 在 src/content/browser/renderer_host/render_process_host_impl.cc 中控制渲染进程获取UA信息
//      - 在 src/services/network/public/cpp/user_agent.cc 中确保网络服务层使用一致的UA
//      - 确保所有进程和上下文中UA信息保持同步，防止通过进程间不一致性检测伪装
//
//   5. 脚本执行环境与权限防护：
//      - 在 src/third_party/blink/renderer/core/executed_script/executed_script_permissions.cc 中处理脚本权限
//      - 确保iframe、worker和其他执行上下文中UA信息一致
//      - 防止通过执行环境差异检测UA伪装
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 防御UA一致性检测：
//      - 确保navigator.userAgent、HTTP头UA和navigator.userAgentData返回一致的信息
//      - 处理navigator.platform、navigator.appVersion、navigator.vendor等相关属性，使其与UA保持一致
//      - 确保navigator.userAgentData.getHighEntropyValues()返回的详细信息与基本UA匹配
//      - 防止通过跨源资源（如iframe、fetch、XHR）检测UA不一致
//
//   2. 防御UA内部结构分析：
//      - 确保伪造UA字符串的内部结构合理，遵循标准格式规范
//      - 处理浏览器版本、操作系统版本和CPU架构信息的逻辑关系
//      - 维护移动设备标识符（如Android、iPhone）与平台信息的一致性
//      - 确保渲染引擎标识（如Gecko、WebKit、Blink）与浏览器标识匹配
//
//   3. 防御功能与特性检测：
//      - 确保伪造UA声明的浏览器功能与实际行为一致（如声明为Safari但支持Chrome专有API）
//      - 处理浏览器特定的JS对象和属性，确保与伪造UA匹配
//      - 确保CSS支持特性与伪造UA声明的浏览器一致
//      - 防止通过功能检测（如特定API支持）间接推断真实UA
//
//   4. 防御Client Hints详细信息泄露：
//      - 处理navigator.userAgentData.brands数组，确保品牌信息与UA一致
//      - 控制navigator.userAgentData.mobile布尔值，确保与设备类型声明一致
//      - 处理navigator.userAgentData.getHighEntropyValues()的Promise返回值，包括
//        architecture、bitness、model、platformVersion等高熵信息
//      - 确保所有Client Hints头部信息与JavaScript API返回值一致
//
//   5. 防御高级UA指纹融合技术：
//      - 防止通过WebRTC、WebGL或Canvas指纹与UA信息交叉验证
//      - 处理UA与屏幕分辨率、触控支持等设备特性的关联一致性
//      - 确保UA与语言设置、时区设置等区域信息保持合理关联
//      - 防止通过JavaScript执行性能特征间接推断设备与UA不匹配
//
// - 自定义UA实现策略：
//   * 提供预定义的UA配置组合，包括常见浏览器（Chrome、Firefox、Safari、Edge）和操作系统（Windows、macOS、Linux、Android、iOS）
//   * 根据选择的UA自动配置所有相关属性和Client Hints
//   * 确保自定义UA的内部一致性，包括版本号、平台信息、移动标志等
//   * 实现UA组件的精细控制，允许用户指定浏览器、版本、操作系统、设备类型等
//   * 确保自定义UA在所有API和请求中保持一致
//
// - 实现"真实"模式的策略：
//   * 使用系统实际的浏览器和操作系统信息生成UA
//   * 保持所有UA相关API和头部的原始行为
//   * 确保客户端提示机制正常工作，返回真实的设备和浏览器信息
//
// - 实现需要注意的边缘情况：
//   * 处理iframe内嵌页面的UA一致性
//   * 确保Service Worker和Web Worker中UA信息同步
//   * 处理跨域请求和第三方资源加载时的UA一致性
//   * 确保浏览器扩展和内容脚本环境中UA保持一致
//   * 处理导航过程中UA的持久性，避免刷新或导航后UA变化
//   * 确保UA伪装不会破坏依赖特定UA的网站功能
//
// - 与其他指纹保护功能的协调：
//   * 与语言指纹（指纹1）协调，确保UA中的语言标识与navigator.language一致
//   * 与平台指纹（指纹31中的navigator.platform）协调，保持平台信息一致性
//   * 与设备内存指纹（指纹23）协调，确保移动设备UA配置了合理的内存值
//   * 与屏幕分辨率指纹（指纹5）协调，确保移动设备UA有合适的屏幕设置
//   * 与WebRTC指纹（指纹13）协调，防止通过网络接口信息推断设备与UA不匹配

29、Plugins (浏览器插件)【噪音 真实 禁用】
// 注意：NPAPI插件已基本被禁用，此指纹项更多是历史遗留或特定环境下的考虑。
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(未找到): src/content/browser/plugins/plugin_service_impl.cc

// 修改实现细节：
// - 浏览器插件（如 Flash）信息可以通过 navigator.plugins 属性获取。这个属性返回一个 PluginArray 对象。
// - 修改的核心在于控制 navigator.plugins 返回的插件列表。
// - src/third_party/blink/renderer/core/frame/navigator.cc 实现了 navigator.plugins 属性。需要修改这里的逻辑，拦截获取真实插件列表的调用，并返回一个伪造的 PluginArray。
// - 实现"真实"返回真实列表，实现"禁用"返回空列表，实现"噪音"返回包含伪造插件信息的列表。
// - 伪造时可以根据固定种子生成伪造的插件名称、描述、文件名和关联的 MIME 类型列表。

30、MimeTypes (MIME 类型)【噪音 真实】
// 可能与插件相关联，参考插件相关文件。
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(已验证): src/content/public/common/content_client.cc
文件路径(已验证): src/third_party/blink/renderer/modules/plugins/navigator_plugins.cc
文件路径(已验证): src/third_party/blink/renderer/modules/plugins/dom_mime_type_array.cc
文件路径(已验证): src/third_party/blink/renderer/modules/plugins/dom_mime_type.cc
文件路径(已验证): src/third_party/blink/renderer/modules/plugins/dom_plugin_array.cc
文件路径(已验证): src/third_party/blink/renderer/modules/plugins/dom_plugin.cc
文件路径(已验证): src/third_party/blink/renderer/core/page/plugin_data.h

// 修改实现细节：
// - MimeTypes指纹是通过navigator.mimeTypes属性获取的浏览器支持的MIME类型列表，这些类型通常与插件相关联
// - MimeTypes与Plugins指纹密切相关，二者应保持一致的防护策略
//
// - 核心修改文件和策略：
//
//   1. 主要控制逻辑：
//      - 在src/third_party/blink/renderer/modules/plugins/navigator_plugins.cc中的ShouldReturnFixedPluginData()函数
//        决定是否返回标准化的插件和MIME类型列表
//      - 在NavigatorPlugins类的构造函数中设置should_return_fixed_plugin_data_标志
//      - 修改ShouldReturnFixedPluginData()函数，集成到指纹控制框架，根据当前窗口的指纹模式决定行为
//
//   2. MimeTypes实现：
//      - src/third_party/blink/renderer/modules/plugins/dom_mime_type_array.cc实现了navigator.mimeTypes返回的MimeTypeArray
//      - 关键函数包括length()、item()、namedItem()和UpdatePluginData()
//      - 当should_return_fixed_plugin_data_为true时，返回标准化的MIME类型列表
//
//   3. 与Plugin关联：
//      - src/third_party/blink/renderer/modules/plugins/dom_plugin_array.cc中的GetFixedMimeTypeArray()函数
//        提供标准化的MIME类型列表
//      - 这些MIME类型通过MakeFakePlugin()函数创建的伪造插件关联
//      - 伪造插件主要是PDF相关的插件，如"PDF Viewer"、"Chrome PDF Viewer"等
//
// - 针对最新指纹检测技术的防护措施：
//
//   1. 模式与策略：
//      - "真实"模式：返回浏览器实际支持的MIME类型列表
//      - "噪音"模式：返回标准化的MIME类型列表，降低指纹识别率
//        * 基于指纹控制框架的种子，生成一致但随机的MIME类型列表
//        * 确保所有MIME类型与其关联的插件在逻辑上保持一致
//        * 保持MIME类型数量在合理范围内，避免异常检测
//
//   2. 一致性保护：
//      - 确保navigator.mimeTypes、navigator.plugins和HTTP请求头中的信息保持一致
//      - 处理mimeTypes.namedItem()方法，确保通过名称查询MIME类型的行为符合预期
//      - 确保enabledPlugin属性正确引用关联的插件对象
//      - 在iframe和其他执行上下文中保持一致的MIME类型列表
//
//   3. 内部结构保护：
//      - 确保MimeType对象的内部属性（type、description、suffixes）格式符合标准
//      - 处理MIME类型与文件扩展名的映射关系，确保逻辑合理
//      - 维护MIME类型数组的正确索引行为，包括数字索引和名称索引
//
//   4. API行为保护：
//      - 确保MimeTypeArray对象的length属性返回正确的MIME类型数量
//      - 处理item()、namedItem()等方法的行为，保持与标准规范一致
//      - 确保通过for...in遍历MimeTypeArray时的行为正确
//      - 保护对象的原型链和属性描述符，防止通过元编程技术检测
//
// - 具体实现建议：
//
//   1. 修改NavigatorPlugins.cc中的ShouldReturnFixedPluginData函数：
//      ```cpp
//      bool ShouldReturnFixedPluginData(Navigator& navigator) {
//        // 使用指纹控制器决定是否返回固定插件数据
//        auto* controller = fingerprint_protection::FingerprintController::GetInstance();
//        if (controller && navigator.DomWindow() && navigator.DomWindow()->GetFrame()) {
//          uint64_t window_id = navigator.DomWindow()->GetFrame()->GetWindowId();
//          fingerprint_protection::FingerprintMode mode = controller->GetModeForWindow(window_id);
//          
//          // 真实模式返回实际插件数据，其他模式返回固定数据
//          return mode != fingerprint_protection::FingerprintMode::REAL;
//        }
//        
//        // 默认返回固定插件数据以增强隐私保护
//        return true;
//      }
//      ```
//
//   2. 增强DOMPluginArray中的GetFixedMimeTypeArray函数，支持基于种子的噪音生成：
//      ```cpp
//      HeapVector<Member<DOMMimeType>> DOMPluginArray::GetFixedMimeTypeArray() {
//        HeapVector<Member<DOMMimeType>> mimetypes;
//        
//        // 使用指纹控制器
//        auto* controller = fingerprint_protection::FingerprintController::GetInstance();
//        if (controller && DomWindow() && DomWindow()->GetFrame()) {
//          uint64_t window_id = DomWindow()->GetFrame()->GetWindowId();
//          std::string domain = DomWindow()->document()->Url().Host().Utf8();
//          fingerprint_protection::FingerprintMode mode = controller->GetModeForWindow(window_id);
//          
//          // 配置标准MIME类型
//          if (dom_plugins_.empty())
//            return mimetypes;
//            
//          // 添加PDF相关MIME类型
//          mimetypes.push_back(dom_plugins_[0]->item(0));  // application/pdf
//          mimetypes.push_back(dom_plugins_[0]->item(1));  // text/pdf
//          
//          // 噪音模式可以添加额外的MIME类型
//          if (mode == fingerprint_protection::FingerprintMode::NOISE) {
//            // 根据种子决定添加哪些额外MIME类型
//            // ...
//          }
//        }
//        return mimetypes;
//      }
//      ```
//
// - 与其他指纹保护功能的协调：
//   * 与插件指纹（指纹29）保持一致，确保MIME类型列表与插件列表匹配
//   * 与User-Agent指纹（指纹28）协调，确保MIME类型与声明的浏览器身份一致
//   * 与Navigator附加属性（指纹31）协调，保持平台特性一致性

31、Navigator 附加属性【真实 自定义】
// 包括但不限于 platform, oscpu, product, vendor, appCodeName, appName, appVersion 等。
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(已验证): src/base/system/sys_info.cc
文件路径(已验证): src/base/version_info/version_info.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_id.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_id.h
文件路径(已更新): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_concurrent_hardware.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_device_memory.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator_language.cc
文件路径(已验证): src/third_party/blink/renderer/modules/plugins/navigator_plugins.cc
文件路径(未找到): src/third_party/blink/renderer/modules/presentation/navigator_presentation.cc
文件路径(未找到): src/third_party/blink/renderer/modules/permissions/navigator_permissions.cc
文件路径(未找到): src/third_party/blink/renderer/modules/storage/navigator_storage.cc
文件路径(未找到): src/third_party/blink/renderer/modules/mediasession/navigator_media_session.cc
文件路径(未找到): src/third_party/blink/renderer/modules/serviceworkers/navigator_service_worker.cc
文件路径(未找到): src/third_party/blink/renderer/modules/cookie_store/navigator_cookie_store.cc
文件路径(未找到): src/third_party/blink/renderer/modules/xr/navigator_xr.cc
文件路径(未找到): src/third_party/blink/renderer/modules/netinfo/navigator_network_information.cc
文件路径(未找到): src/third_party/blink/renderer/modules/mediastream/navigator_media_devices.cc
文件路径(未找到): src/third_party/blink/renderer/modules/clipboard/navigator_clipboard.cc
文件路径(已验证): src/third_party/blink/renderer/core/workers/worker_navigator.cc
文件路径(已验证): src/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc
文件路径(已验证): src/third_party/blink/renderer/core/execution_context/execution_context.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/dom_window.cc

// 修改实现细节：
// - Navigator附加属性是现代指纹识别中的重要组成部分，不仅包括基础标识信息，还涵盖了硬件、网络、媒体和权限等广泛领域。
//
// - 核心修改文件和策略：
//
//   1. 基础Navigator标识信息防护：
//      - 在 src/third_party/blink/renderer/core/frame/navigator.cc 和 navigator_id.cc 中修改基本属性实现
//      - 处理以下核心标识属性：
//        * navigator.platform - 操作系统/平台标识
//        * navigator.appCodeName - 浏览器代码名
//        * navigator.appName - 浏览器名称
//        * navigator.appVersion - 浏览器版本
//        * navigator.product - 产品名称（通常为"Gecko"）
//        * navigator.productSub - 产品次版本
//        * navigator.vendor - 浏览器供应商
//        * navigator.vendorSub - 供应商次版本
//      - 确保所有这些属性与User-Agent（指纹28）保持逻辑一致
//
//   2. 硬件信息属性防护：
//      - 在 src/third_party/blink/renderer/core/frame/navigator_concurrent_hardware.cc 中处理 hardwareConcurrency 属性
//      - 在 src/third_party/blink/renderer/core/frame/navigator_device_memory.cc 中处理 deviceMemory 属性
//      - 确保硬件信息与设备类型和操作系统匹配（如移动设备应有合理的内存和核心数）
//      - 与硬件并发数（指纹21）和设备内存（指纹23）指纹保持一致
//
//   3. 网络和连接信息防护：
//      - 在 src/third_party/blink/renderer/modules/netinfo/navigator_network_information.cc 中处理 connection 属性
//      - 控制 navigator.connection.type、effectiveType、downlink、rtt 等网络特性
//      - 确保网络信息与设备类型和使用场景匹配（如移动设备有合理的连接类型）
//
//   4. 媒体能力和设备防护：
//      - 在 src/third_party/blink/renderer/modules/mediastream/navigator_media_devices.cc 中处理 mediaDevices 属性
//      - 在 src/third_party/blink/renderer/modules/mediasession/navigator_media_session.cc 中处理 mediaSession 属性
//      - 与媒体设备指纹（指纹37）协调，确保媒体设备列表与平台特性一致
//
//   5. 存储和权限相关防护：
//      - 在 src/third_party/blink/renderer/modules/permissions/navigator_permissions.cc 中处理 permissions 接口
//      - 在 src/third_party/blink/renderer/modules/storage/navigator_storage.cc 中处理 storage 接口
//      - 在 src/third_party/blink/renderer/modules/cookie_store/navigator_cookie_store.cc 中处理 cookieStore 接口
//      - 确保权限和存储状态与平台类型和浏览器身份一致
//
//   6. 功能特性和API可用性防护：
//      - 在 src/third_party/blink/renderer/modules/xr/navigator_xr.cc 中处理 xr 接口（WebXR）
//      - 在 src/third_party/blink/renderer/modules/serviceworkers/navigator_service_worker.cc 中处理 serviceWorker 接口
//      - 在 src/third_party/blink/renderer/modules/presentation/navigator_presentation.cc 中处理 presentation 接口
//      - 在 src/third_party/blink/renderer/modules/clipboard/navigator_clipboard.cc 中处理 clipboard 接口
//      - 确保特性可用性与伪造的浏览器身份一致（如Safari不应支持Chrome专有API）
//
//   7. Worker和不同执行上下文防护：
//      - 在 src/third_party/blink/renderer/core/workers/worker_navigator.cc 中处理Worker环境中的Navigator对象
//      - 在 src/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc 中处理专用Worker的全局作用域
//      - 在 src/third_party/blink/renderer/core/execution_context/execution_context.cc 中处理不同执行上下文
//      - 确保所有执行环境中的Navigator属性保持一致，防止通过Worker环境检测不一致
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 防御属性一致性检测：
//      - 确保所有Navigator属性与User-Agent和平台特性在逻辑上保持一致
//      - 处理属性之间的相互关联，如platform与硬件信息、语言与区域设置等
//      - 在不同执行上下文（主线程、iframe、worker）中保持一致的属性值
//
//   2. 防御功能可用性检测：
//      - 处理navigator对象上存在但值为null或undefined的属性，确保与伪造的浏览器身份一致
//      - 处理不同浏览器特有的属性（如Safari的standalone、Chrome的pdfViewerEnabled）
//      - 确保API可用性与声明的浏览器和平台匹配，防止通过特性检测识别伪装
//
//   3. 防御属性行为检测：
//      - 处理navigator属性的可枚举性、可写性和可配置性
//      - 确保Object.getOwnPropertyDescriptor(navigator, 'xyz')返回合理的属性描述符
//      - 处理属性访问器的toString()行为，确保返回合理的原生代码表示
//
//   4. 防御动态属性和事件检测：
//      - 处理navigator.onLine属性和online/offline事件的一致性
//      - 处理navigator.connection的change事件，确保事件触发与属性变化同步
//      - 确保动态属性（如connection.downlink）的变化模式合理
//
//   5. 防御原型链检测：
//      - 确保navigator.__proto__、Navigator.prototype等原型链符合标准浏览器实现
//      - 处理Navigator接口的继承关系（如NavigatorID、NavigatorLanguage等mixin）
//      - 防止通过检测原型方法和属性识别非标准实现
//
//   6. 防御Promise返回值检测：
//      - 处理navigator.permissions.query()、navigator.storage.estimate()等返回Promise的方法
//      - 确保Promise解析值的结构和内容与伪造的浏览器身份一致
//      - 处理异步API的时序特性，防止通过响应时间模式识别
//
// - 自定义模式实现策略：
//   * 新增"自定义"模式，允许精细控制各Navigator属性
//   * 根据选择的浏览器和平台身份自动配置相关属性集合
//   * 提供预定义的配置模板（如"Chrome on Windows"、"Safari on iPhone"等）
//   * 确保自定义设置在所有属性间保持逻辑一致性
//   * 允许高级用户调整特定属性，同时提供一致性验证
//
// - 实现"真实"模式的策略：
//   * 使用系统实际信息初始化所有Navigator属性
//   * 保持各接口的原始实现，不进行拦截或修改
//   * 确保真实模式下的属性访问不引入额外开销
//
// - 实现需要注意的边缘情况：
//   * 处理navigator对象上不存在的属性访问（返回undefined而不是错误）
//   * 确保属性修改行为符合标准（多数Navigator属性应为只读）
//   * 处理调试工具和开发者工具中的Navigator检查
//   * 确保iframe沙盒限制下的Navigator属性行为一致
//   * 处理ServiceWorker和SharedWorker中的Navigator属性
//   * 考虑低版本浏览器兼容性（某些新属性在旧版中不存在）
//
// - 与其他指纹保护功能的协调：
//   * 与User-Agent指纹（指纹28）保持一致，确保浏览器身份匹配
//   * 与硬件并发数（指纹21）和设备内存（指纹23）协调
//   * 与语言指纹（指纹1和2）协调，确保navigator.language一致
//   * 与媒体设备指纹（指纹37）协调，确保设备能力匹配
//   * 与插件指纹（指纹29）协调，确保plugins属性一致
//   * 与WebDriver标志（指纹33）协调，确保自动化检测行为一致

32、设备像素比 (devicePixelRatio)【真实 固定 噪音】
文件路径(已验证): src/third_party/blink/renderer/core/frame/local_dom_window.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/local_frame.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/local_frame.h
文件路径(已验证): src/third_party/blink/renderer/core/page/page.cc
文件路径(已验证): src/third_party/blink/renderer/core/page/page.h
文件路径(已验证): src/ui/display/screen.cc

// 修改实现细节：
// - 设备像素比（Device Pixel Ratio, DPR）通过 window.devicePixelRatio 属性暴露给 JavaScript，是指纹识别中重要的硬件信息。
// - 关键修改点包括：
//   1. 在 src/ui/display/screen.cc 中修改获取真实DPR的相关函数，拦截系统调用，根据指纹模式返回适当的DPR值。
//   2. 在 src/third_party/blink/renderer/core/frame/local_frame.cc 中修改 DevicePixelRatio() 函数，使其通过指纹控制器获取DPR值。
//   3. 在 src/third_party/blink/renderer/core/page/page.cc 中修改 InspectorDeviceScaleFactorOverride() 方法，支持指纹防护模式。
//   4. 在 src/third_party/blink/renderer/core/frame/local_dom_window.cc 中的 devicePixelRatio() 方法调用帧的 DevicePixelRatio()，无需直接修改。
// - 实现三种模式：
//   * "真实"模式：返回系统实际的DPR值。
//   * "固定"模式：返回标准化的DPR值（如1.0或2.0），与声称的设备和浏览器一致。
//   * "噪音"模式：基于一个固定种子生成稳定的微小随机偏差（如1.975代替2.0），保持会话一致性。
// - 协调性考虑：
//   * 与屏幕分辨率指纹（指纹30）协调，确保DPR与分辨率比例合理。
//   * 与媒体查询（指纹13）协调，确保@media (device-pixel-ratio)查询匹配相同的值。
//   * 与Canvas/WebGL指纹（指纹16和17）协调，确保渲染分辨率与DPR一致。
//   * 与硬件并发数（指纹21）和设备内存（指纹23）协调，保持硬件指标一致性。

33、WebDriver/自动化标志【真实 禁用 噪音】
// 检测 navigator.webdriver 属性或其他自动化痕迹。
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator.h
文件路径(已验证): src/third_party/blink/renderer/core/probe/core_probes.h
文件路径(未找到): src/third_party/blink/renderer/core/probe/core_probe_sink.h
文件路径(未找到): src/third_party/blink/renderer/core/probe/core_probe_sink.cc
文件路径(已验证): src/content/renderer/render_frame_impl.cc
文件路径(未找到): src/content/browser/webdriver/automation_controller.cc
文件路径(已验证): src/components/embedder_support/user_agent_utils.cc

// 修改实现细节：
// - WebDriver/自动化标志是现代网站检测自动化浏览器的主要方式，包括多种检测方法和特征。
// - 关键修改点包括：
//   1. 在 src/third_party/blink/renderer/core/frame/navigator.cc 中修改 navigator.webdriver 属性的 getter 方法，
//      使用指纹控制器判断当前模式并返回适当的值。目前实现依赖 probe::ApplyAutomationOverride 函数。
//   2. 在 src/third_party/blink/renderer/core/probe/core_probe_sink.cc 中修改 ApplyAutomationOverride 实现，
//      添加对指纹控制器的调用，实现不同模式下的行为。
//   3. 在 src/content/browser/webdriver/automation_controller.cc 中修改自动化状态传递机制，确保全局一致性。
//   4. 在 src/content/renderer/render_frame_impl.cc 中确保 RenderFrame 对自动化状态的处理符合指纹模式要求。
//   5. 在 src/components/embedder_support/user_agent_utils.cc 中修改自动化相关标识符在用户代理字符串中的处理。
// - 实现三种模式：
//   * "真实"模式：返回浏览器真实的自动化状态，如果正在使用WebDriver或自动化工具则返回true。
//   * "禁用"模式：无论实际自动化状态如何，始终返回false，隐藏所有自动化痕迹。
//   * "噪音"模式：在大多数情况下隐藏自动化特征，但在某些不重要的属性上引入细微变化，以避免过于一致而被检测。
// - 需要特别处理的检测方法：
//   1. navigator.webdriver 属性：这是最直接和常用的检测方法，核心修改点。
//   2. 运行时特征检测：许多检测库使用行为分析，如异常模式、缺失功能或非标准行为来识别自动化。
//   3. 浏览器功能一致性：确保弹窗、权限请求等行为与普通浏览器一致。
//   4. 用户代理字符串：移除或修改可能泄露自动化状态的标识符，如"HeadlessChrome"。
//   5. DevTools协议痕迹：屏蔽或伪造与Chrome DevTools Protocol连接相关的痕迹。
// - 协调性考虑：
//   * 与用户代理指纹（指纹4）协调，确保UA字符串中不包含自动化相关标识。
//   * 与WebGL/Canvas指纹（指纹16和17）协调，确保渲染行为一致。
//   * 与CDP连接/自动化检测防护（指纹35）协调，形成完整的自动化防护方案。
//   * 与无头模式指纹防护（指纹43）协调，共同处理自动化环境的检测问题。
// - 防护效果优化：
//   * 实现动态调整的行为模拟，使其不仅在静态特征上隐藏自动化状态，还在交互行为上模拟真实用户。
//   * 对基于异步行为或时序分析的高级检测技术提供防护，如模拟真实的人类输入延迟模式。

34、TLS ClientHello【真实 噪音】
// 客户端在TLS握手时发送的信息，包括支持的加密套件、扩展等。
文件路径(已验证): src/net/ssl/ssl_config_service.cc
文件路径(已验证): src/net/socket/ssl_client_socket_impl.cc
文件路径(已验证): src/net/ssl/ssl_cipher_suite_names.cc
文件路径(已验证): src/net/ssl/ssl_client_session_cache.cc

// 修改实现细节：
// - TLS ClientHello 指纹是通过检查浏览器在 TLS 握手时发送的 ClientHello 消息来获取信息。
// - 修改的核心在于控制 ClientHello 消息的内容，主要包括以下几个方面：
//   1. 支持的协议版本（Protocol Versions）
//   2. 加密套件（Cipher Suites）
//   3. 扩展列表及其顺序（Extensions）
//   4. 支持的曲线（Curves）
//   5. 支持的签名算法（Signature Algorithms）
//   6. ALPN 协议
//   7. ECH 配置（加密客户端 Hello）

// - 修改流程和关键函数：
//   1. 在 src/net/socket/ssl_client_socket_impl.cc 的 Init() 方法中修改，该方法负责初始化 SSL 上下文和配置 TLS 参数。
//   2. 特别关注以下几个关键函数调用，这些是决定 ClientHello 特征的主要点：
//      - SSL_set_min_proto_version / SSL_set_max_proto_version：设置 TLS 协议版本范围
//      - SSL_set_cipher_list：设置加密套件列表及其顺序
//      - SSL_set1_curves：设置椭圆曲线列表及其顺序
//      - SSL_set_verify_algorithm_prefs：设置签名算法偏好
//      - SSL_set_alpn_protos：设置 ALPN 协议列表
//      - SSL_set_permute_extensions：设置是否随机排列 TLS 扩展（防指纹措施）
//      - SSL_set_options / SSL_clear_options：设置和清除 SSL 选项标志
//      - SSL_set_mode / SSL_clear_mode：设置和清除 SSL 模式标志

// - 实现"真实"模式：
//   1. 直接使用系统默认设置和 Chromium 的默认配置，不做任何修改。
//   2. 此模式下，ClientHello 消息将保持其原始格式，使用用户操作系统和浏览器版本特有的设置。

// - 实现"噪音"模式：
//   1. 在 Init() 方法中添加指纹模式判断逻辑，如果是"噪音"模式，修改 ClientHello 参数。
//   2. 修改 SSLClientSocketImpl 类，添加一个新的方法 ApplyFingerprintMode() 用于根据指纹模式修改 SSL 配置。
//   3. 添加基于固定种子的随机配置生成逻辑，这样每个相同指纹ID的实例会生成相同的"噪音"配置：
//      - 随机选择一部分 cipher suite 子集并重新排序
//      - 随机选择曲线列表的子集并重新排序
//      - 随机调整 TLS 扩展的顺序（启用 SSL_set_permute_extensions）
//      - 根据种子随机启用或禁用某些 TLS 扩展
//      - 调整 ALPN 协议列表
//      - 可能的话，微调 ClientHello 记录的分片大小

// - 代码实现示例（伪代码）：
// ```
// void SSLClientSocketImpl::ApplyFingerprintMode(FingerprintMode mode, uint64_t seed) {
//   if (mode == FINGERPRINT_MODE_REAL) {
//     // 使用真实配置，不做任何修改
//     return;
//   }
//   
//   if (mode == FINGERPRINT_MODE_NOISE) {
//     // 使用随机数生成器，以 seed 为种子
//     std::mt19937_64 rng(seed);
//     
//     // 1. 修改加密套件列表
//     std::string cipher_command = GenerateRandomCipherListCommand(rng);
//     SSL_set_strict_cipher_list(ssl_.get(), cipher_command.c_str());
//     
//     // 2. 修改曲线列表
//     std::vector<int> curves = GenerateRandomCurveList(rng);
//     SSL_set1_curves(ssl_.get(), curves.data(), curves.size());
//     
//     // 3. 修改签名算法偏好
//     std::vector<uint16_t> sig_algs = GenerateRandomSignatureAlgorithms(rng);
//     SSL_set_verify_algorithm_prefs(ssl_.get(), sig_algs.data(), sig_algs.size());
//     
//     // 4. 随机启用或禁用 TLS 扩展排列
//     bool permute_extensions = (rng() % 2) == 0;
//     SSL_set_permute_extensions(ssl_.get(), permute_extensions);
//     
//     // 5. 随机设置 SSL 选项和模式
//     SslSetClearMask options;
//     ConfigureRandomSSLOptions(options, rng);
//     SSL_set_options(ssl_.get(), options.set_mask);
//     SSL_clear_options(ssl_.get(), options.clear_mask);
//   }
// }
// ```

// - 协调性考虑：
//   * 与 IP 地址指纹（指纹36）协调，确保 TLS ClientHello 中隐含的地理位置信息与 IP 地址保持一致。
//   * 与用户代理指纹（指纹4）协调，确保 TLS 特征与浏览器类型和版本一致。
//   * 与 HTTP/2 和 HTTP/3 协议特征（指纹27）协调，确保 ALPN 设置与实际协议支持一致。
//   * 与 WebSocket 握手（指纹25）协调，保持 TLS 层与应用层协议的一致性。

// - 安全与性能考虑：
//   * 不应禁用或降低 TLS 安全设置，如 TLS 1.3 支持或强密码套件。
//   * 噪音模式下，确保生成的配置依然能与现代网站兼容。
//   * 避免增加 TLS 握手延迟，可以预先计算和缓存指纹配置。

35、CDP 连接 / 自动化检测防护【开启保护 关闭保护】
// 涉及 Chrome DevTools Protocol 的使用和相关痕迹的隐藏。
文件路径(未找到): src/content/browser/devtools/ (目录)
文件路径(未找到): src/third_party/blink/renderer/core/inspector/ (目录)
文件路径(未找到): src/third_party/blink/public/common/features.h // 可能通过 feature flag 控制
文件路径(已验证): src/content/browser/devtools/protocol/target_handler.cc
文件路径(已验证): src/content/browser/devtools/browser_devtools_agent_host.cc
// 可能需要查找处理特定 CDP 命令的代码，例如 Runtime.evaluate, Page.addScriptToEvaluateOnNewDocument 等，以及与自动化相关的检测点。

// 修改实现细节：
// - 这项指纹关注的是检测浏览器是否连接了 Chrome DevTools Protocol (CDP) 或者运行在自动化环境中（例如 headless 模式）。
// - 修改的核心在于隐藏 CDP 连接的痕迹和伪造自动化相关的检测点。
// - src/content/browser/devtools/ 和 src/third_party/blink/renderer/core/inspector/ 这两个目录包含了 DevTools 和 Inspector 的实现代码。可以在这些文件中找到与 CDP 通信、会话管理相关的逻辑，修改这些逻辑以减少痕迹暴露。
// - src/third_party/blink/public/common/features.h 可能定义了控制 DevTools 或自动化相关功能的特性标志。
// - src/content/browser/devtools/protocol/target_handler.cc 处理DevTools协议中的目标管理，是远程调试和自动化的核心组件，修改此处可以控制CDP暴露的目标信息和功能。
// - src/content/browser/devtools/browser_devtools_agent_host.cc 实现DevTools代理，负责浏览器级别的调试功能，是检测自动化和远程控制的关键点。
// - 防止检测通常涉及到识别网站可能用来检测 CDP 或自动化的技术，然后在代码中针对性地进行伪造或隐藏。

指纹保护总体控制文件(已验证):
文件路径(已验证): src/components/privacy_sandbox/tracking_protection_settings.h
文件路径(已验证): src/components/privacy_sandbox/tracking_protection_settings.cc
文件路径(已验证): src/components/privacy_sandbox/tracking_protection_prefs.h
文件路径(已验证): src/components/privacy_sandbox/tracking_protection_prefs.cc

36、IP地址【真实 自定义】
// 网站通过用户的IP地址获取地理位置信息，可用于识别用户、定制内容和安全检查。
// 现代检测技术会通过多种方式获取IP并进行交叉验证，需要全面防护。

核心文件路径:
- src/net/base/network_interfaces.cc (网络接口枚举)
- src/services/network/network_service.cc (网络服务层)
- src/net/url_request/url_request.cc (HTTP请求处理)

新增关键文件:
- src/net/dns/host_resolver_impl.cc (DNS解析防护)
- src/net/base/network_change_notifier.cc (网络状态监控)
- src/net/socket/tcp_socket.cc (TCP套接字层)
- src/net/socket/udp_socket.cc (UDP套接字层)
- src/third_party/webrtc/p2p/base/stun_request.cc (STUN请求拦截)
- src/components/dns_over_https/dns_over_https_server_config.cc (DoH防护)

协同指纹项目:
- 与项目13 WebRTC深度集成，确保IP一致性
- 与项目7 地理位置指纹协调，保证地理信息合理性
- 与项目8 时区指纹匹配，维护IP-时区逻辑一致性

检测对抗策略:
- 实现多层IP获取方式的统一控制
- 建立IP-地理位置-时区的一致性验证机制
- 动态响应网络环境变化，保持指纹稳定性
- 防范基于网络延迟的IP真实性检测

37、媒体设备指纹【噪音 真实 禁用】
// 媒体设备指纹基于浏览器可访问的媒体输入/输出设备列表（如麦克风、摄像头）。
// 现代检测技术会分析设备能力、权限行为和媒体流元数据，需要全面防护。

核心文件路径:
- src/third_party/blink/renderer/modules/mediastream/media_devices.cc (设备枚举核心)
- src/content/browser/renderer_host/media/media_devices_manager.cc (设备管理器)
- src/third_party/blink/public/mojom/mediastream/media_devices.mojom (Mojo接口)

权限管理防护:
- src/content/browser/media/media_stream_manager.cc (媒体流权限管理)
- src/third_party/blink/renderer/modules/mediastream/user_media_request.cc (用户媒体请求)
- src/content/browser/permissions/permission_manager_impl.cc (权限管理器)
- src/components/permissions/permission_context_base.cc (权限上下文)

设备能力控制:
- src/media/base/video_capture_types.cc (视频捕获类型)
- src/media/base/audio_parameters.cc (音频参数)
- src/third_party/blink/renderer/modules/mediastream/media_track_capabilities.cc (轨道能力)
- src/media/capture/video/video_capture_device_descriptor.cc (设备描述符)

跨平台设备监控:
- src/media/device_monitors/device_monitor_udev.h (Linux设备监控)
- src/media/device_monitors/device_monitor_win.cc (Windows设备监控)
- src/media/device_monitors/device_monitor_mac.cc (macOS设备监控)

媒体流元数据防护:
- src/third_party/blink/renderer/modules/mediastream/media_stream_track.cc (媒体轨道)
- src/third_party/blink/renderer/modules/mediastream/media_stream_video_track.cc (视频轨道)
- src/third_party/blink/renderer/modules/mediastream/media_stream_audio_track.cc (音频轨道)

检测对抗策略:
- 实现设备ID的智能生成，确保格式合理性
- 建立设备能力与硬件规格的一致性验证
- 控制权限请求的时序和行为模式
- 确保媒体流质量与设备能力的匹配
- 维护设备列表变化的合理性

协同指纹项目:
- 与硬件指纹保持设备兼容性一致
- 与操作系统指纹协调设备驱动信息
- 与网络指纹匹配带宽处理能力

38、SpeechVoices【噪音 真实 禁用】
文件路径(核心): src/third_party/blink/renderer/modules/speech/speech_synthesis.cc
文件路径(新增): src/third_party/blink/renderer/modules/speech/speech_synthesis_voice.cc
文件路径(新增): src/third_party/blink/renderer/modules/speech/speech_synthesis_voice.h
文件路径(新增): src/third_party/blink/public/mojom/speech/speech_synthesis.mojom
文件路径(新增): src/third_party/blink/renderer/modules/speech/testing/mojom_speech_synthesis_mock.cc
文件路径(新增): src/third_party/blink/renderer/modules/speech/speech_synthesis.idl

// 修改实现细节：
// - SpeechVoices 指纹已超越简单的语音列表检测，现代指纹技术通过语音属性一致性、
//   平台特定语音引擎特征和动态语音包行为等多维度进行检测。
//
// - 核心修改文件和策略：
//
//   1. JavaScript接口层防护：
//      - 在 speech_synthesis.cc 中修改 getVoices() 方法和 OnSetVoiceList() 回调
//      - 在 speech_synthesis_voice.cc 中控制 SpeechSynthesisVoice 对象的属性暴露
//      - 确保 voiceURI、name、lang、localService、default 属性的一致性
//
//   2. Mojo接口层防护：
//      - 在 speech_synthesis.mojom 中处理语音列表的跨进程传递
//      - 在 mojom_speech_synthesis_mock.cc 中实现自定义语音列表模拟
//      - 控制 SpeechSynthesisVoiceListObserver 的语音数据传递
//
//   3. 事件系统防护：
//      - 控制 voiceschanged 事件的触发时机，避免暴露真实语音包变化
//      - 处理语音列表动态更新的一致性，确保事件触发符合伪造配置
//      - 在 speech_synthesis.idl 中确保接口定义与实现一致
//
//   4. 平台特定防护：
//      - 处理 Windows SAPI、macOS Speech Synthesis、Linux espeak 等平台差异
//      - 确保不同平台下的语音列表格式和属性保持一致
//      - 统一跨平台的语音引擎特征表现
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 防御语音属性一致性检测：
//      - 确保语音的 lang 属性与 navigator.language 设置逻辑一致
//      - 验证 localService 属性与实际语音合成能力匹配
//      - 处理 default 语音的选择逻辑，避免暴露系统偏好
//
//   2. 防御语音合成功能验证：
//      - 确保列表中的语音都能正常进行语音合成
//      - 处理语音合成失败时的错误信息，避免暴露真实语音引擎状态
//      - 统一不同语音的合成质量和特征
//
//   3. 防御动态语音包检测：
//      - 模拟语音包的安装和卸载行为
//      - 控制语音列表在页面生命周期内的稳定性
//      - 处理系统语言变更对语音列表的影响
//
//   4. 防御平台特征检测：
//      - 统一不同操作系统的语音命名规范
//      - 处理移动端和桌面端语音引擎的差异
//      - 确保语音列表与设备类型配置一致
//
// - 检测对抗策略：
//   * 智能语音列表生成：基于目标操作系统和语言设置生成合理语音列表
//   * 语音属性验证：确保所有语音属性与系统配置逻辑一致
//   * 动态行为模拟：模拟真实的语音包管理和系统集成行为
//   * 跨平台一致性：统一不同平台的语音引擎表现特征
//
// - 协同指纹项目：
//   * 与操作系统指纹协调语音引擎和系统语言设置
//   * 与语言指纹确保语音列表与浏览器语言配置一致
//   * 与硬件指纹匹配设备类型的语音引擎特征

39、localStorage本地储存【隔离 禁用】
文件路径(核心): src/third_party/blink/renderer/modules/storage/storage_area.cc
文件路径(核心): src/third_party/blink/renderer/modules/storage/dom_window_storage.cc
文件路径(核心): src/components/services/storage/dom_storage/storage_area_impl.cc
文件路径(核心): src/components/services/storage/storage_service_impl.cc
文件路径(核心): src/third_party/blink/renderer/modules/storage/storage_namespace.cc
文件路径(核心): src/content/browser/dom_storage/dom_storage_context_wrapper.cc
文件路径(核心): src/storage/browser/quota/quota_manager_impl.cc
文件路径(新增): src/third_party/blink/renderer/modules/storage/storage_event.cc
文件路径(未找到): src/third_party/blink/renderer/modules/storage/storage_event_dispatcher.cc
文件路径(未找到): src/third_party/blink/renderer/modules/storage/navigator_storage.cc
文件路径(未找到): src/third_party/blink/renderer/modules/storage/storage_manager.cc
文件路径(未找到): src/content/browser/storage_partition_impl.cc
文件路径(未找到): src/content/browser/service_worker/service_worker_storage.cc
文件路径(未找到): src/third_party/blink/renderer/core/inspector/inspector_dom_storage_agent.cc
文件路径(新增): src/third_party/blink/renderer/modules/storage/storage_area.h

// 修改实现细节：
// - localStorage指纹已超越简单的数据存储检测，现代指纹技术通过存储事件、
//   容量检测、性能分析和跨域行为等多维度进行检测。
//
// - 核心修改文件和策略：
//
//   1. 基础存储操作防护：
//      - 在 storage_area.cc 中修改 CanAccessStorage()、getItem()、setItem()、removeItem()、clear() 方法
//      - 在 dom_window_storage.cc 中控制 GetOrCreateLocalStorage() 和 GetOrCreateSessionStorage() 方法
//      - 在 storage_area_impl.cc 中处理底层存储数据的管理和持久化逻辑
//      - 确保localStorage和sessionStorage使用一致的防护策略
//
//   2. 存储事件系统防护：
//      - 在 storage_event.cc 和 storage_event_dispatcher.cc 中控制storage事件的触发和传播
//      - 处理跨窗口、跨标签页的存储事件同步，确保隔离模式下事件不泄露状态
//      - 在禁用模式下完全抑制存储事件的触发
//      - 防止通过iframe和Service Worker监听存储事件
//
//   3. 现代存储API防护：
//      - 在 navigator_storage.cc 和 storage_manager.cc 中控制 navigator.storage API
//      - 处理 storage.estimate() 返回的容量信息，确保与指纹配置一致
//      - 控制 storage.persist() 的权限请求和持久化行为
//      - 防止通过存储配额检测推断设备信息
//
//   4. 跨域和安全上下文防护：
//      - 在 storage_partition_impl.cc 中处理不同安全上下文的存储隔离
//      - 在 service_worker_storage.cc 中控制Service Worker的存储访问
//      - 确保iframe、Web Worker等上下文的存储行为一致性
//      - 处理跨域postMessage与存储操作的关联
//
//   5. 开发者工具防护：
//      - 在 inspector_dom_storage_agent.cc 中控制DevTools显示的存储内容
//      - 防止通过调试接口暴露真实存储状态和配置
//      - 处理存储操作的错误信息和调试日志
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 防御存储容量检测：
//      - 统一不同存储API报告的容量限制
//      - 处理存储配额超限时的错误行为一致性
//      - 防止通过大量写入操作测试真实存储容量
//      - 确保存储清理和垃圾回收的触发阈值与伪造配置一致
//
//   2. 防御存储性能分析：
//      - 标准化存储操作的执行时间，避免暴露设备性能特征
//      - 控制大数据量存储的性能表现
//      - 处理存储操作的并发性能特征
//      - 确保存储I/O模式不暴露底层存储介质类型
//
//   3. 防御存储事件时序分析：
//      - 确保存储事件的触发时机与实际操作同步
//      - 处理多窗口环境下的事件传播延迟
//      - 防止通过事件时序推断浏览器架构和进程模型
//      - 统一不同浏览器模式下的事件行为
//
//   4. 防御跨域存储关联：
//      - 确保不同域名下的存储隔离严格执行
//      - 处理子域名和端口变化对存储访问的影响
//      - 防止通过iframe嵌套检测存储隔离策略
//      - 控制Service Worker跨域存储访问的权限
//
//   5. 防御存储状态持久性检测：
//      - 模拟真实的存储数据持久化行为
//      - 处理浏览器重启后的存储状态恢复
//      - 确保隐私模式和正常模式的存储行为差异符合预期
//      - 控制存储数据的自动清理和过期策略
//
// - 检测对抗策略：
//   * 智能存储容量模拟：基于设备配置生成合理的存储限制和性能特征
//   * 存储行为一致性：确保所有存储API的行为逻辑保持一致
//   * 动态存储策略：支持运行时调整存储模式，适应不同检测场景
//   * 跨上下文同步：统一不同执行上下文的存储访问行为
//
// - 协同指纹项目：
//   * 与IndexedDB指纹协调统一的存储策略和容量限制
//   * 与Cookie指纹确保存储隔离的逻辑一致性
//   * 与Cache API协调Service Worker的存储行为
//   * 与设备内存指纹匹配存储容量的合理性

40、Proxy代理【真实 伪造IP】
// 检测浏览器是否使用了代理，以及代理相关的配置信息。
文件路径(已验证): src/net/proxy_resolution/proxy_config_service.cc
文件路径(已验证): src/net/proxy_resolution/configured_proxy_resolution_service.cc
文件路径(已验证): src/net/proxy_resolution/proxy_resolution_service.h
文件路径(已验证): src/net/proxy_resolution/win/windows_system_proxy_resolution_service.cc
文件路径(未找到): src/net/socket/client_socket_pool_manager.cc
文件路径(未找到): src/net/http/http_network_transaction.cc
文件路径(未找到): src/net/url_request/url_request_context.cc
文件路径(未找到): src/services/network/network_context.cc
文件路径(未找到): src/net/proxy_resolution/proxy_bypass_rules.cc
文件路径(未找到): src/third_party/webrtc/rtc_base/network.cc
文件路径(未找到): src/net/base/network_time_tracker.cc
文件路径(未找到): src/net/http/http_stream_factory.cc
文件路径(未找到): src/net/dns/host_resolver_manager.cc

// 修改实现细节：
// - Proxy 指纹可能通过检测网络连接是否经过代理或检查与代理相关的环境变量/配置来获取。
// - 修改的核心在于控制浏览器报告的代理配置信息，或者伪造看起来没有使用代理的网络行为。
// - 需要修改 src/net/proxy_resolution/proxy_config_service.cc 和 src/net/proxy_resolution/proxy_resolver.cc 中获取和解析代理配置的逻辑。
// - 实现"伪造IP"可能与 IP 地址指纹的修改联动，确保通过代理看到的出口IP与伪造的IP一致。
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. WebRTC IP泄露防护：
//      - 修改 src/third_party/webrtc/rtc_base/network.cc 中的网络接口枚举逻辑
//      - 控制ICE候选地址收集过程，确保不泄露本地IP
//      - 处理STUN/TURN服务器响应，防止通过反射地址检测真实IP
//      - 确保所有WebRTC连接使用与浏览器网络请求一致的IP地址
//
//   2. 网络请求特征防护：
//      - 在 src/net/http/http_network_transaction.cc 中处理HTTP事务的代理行为
//      - 控制 src/net/socket/client_socket_pool_manager.cc 中的连接池管理，避免暴露代理使用特征
//      - 处理 src/net/url_request/url_request_context.cc 中的URL请求上下文，确保代理设置一致性
//      - 修改 src/services/network/network_context.cc 中的网络上下文创建和配置逻辑
//
//   3. 时间戳和延迟分析防护：
//      - 处理 src/net/base/network_time_tracker.cc 中的网络时间跟踪，防止通过时间戳分析检测代理
//      - 控制网络请求的延迟特征，模拟合理的直连或代理连接延迟模式
//      - 确保不同类型请求的延迟模式一致，避免通过延迟差异检测代理
//      - 处理HTTP响应头中的时间信息，确保与代理状态一致
//
//   4. 协议特征防护：
//      - 修改 src/net/http/http_stream_factory.cc 中的HTTP流创建逻辑，统一协议协商行为
//      - 控制QUIC、HTTP/2等现代协议的使用特征，避免暴露代理特征
//      - 处理TLS握手过程中的特征，确保与代理状态一致
//      - 统一直连和代理连接的协议支持和协商行为
//
//   5. DNS泄露防护：
//      - 增强 src/net/dns/host_resolver_manager.cc 中的DNS解析管理，防止DNS泄露
//      - 确保所有DNS查询都通过代理进行（如适用）
//      - 处理DNS-over-HTTPS和传统DNS查询的一致性
//      - 防止通过WebSockets/WebRTC等技术绕过同源策略进行DNS查询
//
// - 检测对抗策略：
//   * 智能代理行为模拟：基于目标网络环境模拟合理的网络延迟和带宽特征
//   * 网络行为一致性：确保所有网络API的行为逻辑与代理状态保持一致
//   * 动态代理策略：支持运行时调整代理模式，适应不同检测场景
//   * 跨协议同步：统一不同网络协议的代理行为
//   * 代理连接质量模拟：模拟真实代理的连接质量特征，如延迟波动和带宽限制
//
// - 协同指纹项目：
//   * 与IP地址指纹协调，确保所有网络请求显示一致的IP地址
//   * 与TLS指纹（指纹36）协调，确保TLS握手特征与代理状态一致
//   * 与HTTP请求头指纹（指纹27）协调，避免在请求头中泄露代理信息
//   * 与WebRTC指纹协调，防止通过WebRTC泄露真实IP
//   * 与时区指纹（指纹15）协调，确保时区信息与代理出口地区一致
//   * 与网络性能指纹协调，模拟合理的网络延迟和带宽特征

41、DNS域名系统【真实 噪音】
// 检测浏览器如何解析域名，可能涉及本地DNS缓存、DNS服务器等信息。
文件路径(已验证): src/net/dns/host_resolver.cc
文件路径(已验证): src/net/dns/dns_client.cc
文件路径(未找到): src/net/dns/host_resolver_manager.cc
文件路径(未找到): src/net/dns/dns_transaction.cc
文件路径(未找到): src/net/dns/dns_config_service.cc
文件路径(未找到): src/net/dns/public/dns_over_https_server_config.cc
文件路径(未找到): src/net/dns/resolve_context.cc
文件路径(未找到): src/net/dns/host_cache.cc
文件路径(未找到): src/chrome/browser/net/dns_prefetch_service.cc
文件路径(未找到): src/services/network/public/cpp/resolve_host_client_base.cc
文件路径(未找到): src/net/dns/dns_util.cc
文件路径(未找到): src/net/dns/dns_response.cc

// 修改实现细节：
// - DNS 指纹可能通过测量域名解析时间、检查使用的 DNS 服务器、或通过 WebSockets/WebRTC 等技术绕过同源策略进行 DNS 查询来获取。
// - 修改的核心在于控制浏览器进行 DNS 查询的行为和返回的结果。
// - 需要修改 src/net/dns/host_resolver.cc 中处理域名解析请求的逻辑。
// - src/net/dns/dns_client.cc 是底层的 DNS 客户端实现，可能需要在此处进行更低级别的拦截和修改。
// - 实现"噪音"可以引入随机的解析延迟，或者在返回的解析结果中加入细微变化（如果可能）。
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. DNS解析时间分析防护：
//      - 在 src/net/dns/host_resolver_manager.cc 中实现智能时间模拟算法
//      - 确保DNS解析时间模式与网络环境和域名特性一致
//      - 处理DNS缓存命中和未命中的时间差异，使其符合真实浏览行为
//      - 模拟不同网络条件下的DNS解析时间变化，如移动网络vs固定网络
//
//   2. DNS-over-HTTPS (DoH) 防护：
//      - 修改 src/net/dns/dns_config_service.cc 控制DoH的启用和配置
//      - 在 src/net/dns/public/dns_over_https_server_config.cc 中管理DoH服务器设置
//      - 确保DoH配置与用户隐私设置和网络环境一致
//      - 防止通过DoH行为差异检测用户配置或环境
//
//   3. DNS缓存管理防护：
//      - 修改 src/net/dns/host_cache.cc 中的DNS缓存管理逻辑
//      - 控制缓存项的生命周期、过期时间和刷新行为
//      - 实现智能缓存策略，模拟真实用户的DNS缓存使用模式
//      - 处理浏览器重启后的缓存状态，确保符合预期行为
//
//   4. DNS预取行为防护：
//      - 控制 src/chrome/browser/net/dns_prefetch_service.cc 中的DNS预取逻辑
//      - 确保预取模式与用户浏览行为和网页内容相关性一致
//      - 处理预取触发时机和频率，避免通过异常预取行为识别用户
//      - 模拟真实用户的导航模式下的DNS预取行为
//
//   5. 跨源DNS检测防护：
//      - 防止通过WebRTC、WebSockets等技术绕过同源策略进行DNS查询
//      - 修改 src/net/dns/dns_transaction.cc 确保所有DNS查询的一致性
//      - 处理应用层DNS查询，如通过fetch()或XHR进行的隐式DNS解析
//      - 确保Service Worker和Web Worker中的DNS行为一致性
//
// - 检测对抗策略：
//   * 智能DNS解析时间模拟：基于网络环境和域名特性生成合理的解析时间
//   * DNS行为一致性：确保所有DNS相关API的行为逻辑保持一致
//   * 动态DNS策略：支持运行时调整DNS解析模式，适应不同检测场景
//   * 跨协议DNS同步：统一不同网络协议的DNS解析行为
//   * DNS解析质量模拟：模拟真实网络环境的DNS解析特征，包括偶发解析失败
//   * TTL处理逻辑：确保DNS记录TTL处理符合标准浏览器行为
//
// - 协同指纹项目：
//   * 与Proxy代理（指纹40）协调，确保DNS查询与代理设置一致
//   * 与WebRTC指纹协调，防止通过WebRTC泄露DNS信息
//   * 与网络性能指纹协调，确保DNS解析时间与整体网络性能一致
//   * 与地理位置指纹协调，确保DNS解析结果与地理位置设置一致
//   * 与时区指纹（指纹15）协调，确保DNS行为与时区设置相符

42、IndexedDB【真实 隔离 禁用】
// IndexedDB 是一种客户端存储数据库，可被网站用于存储大量结构化数据，可能包含用户识别信息。
// 注意：隔离通常是基于域名，但指纹防护可能需要更细粒度的控制或伪造。
文件路径(已验证): src/content/browser/indexed_db/indexed_db_database.cc
文件路径(已验证): src/content/browser/indexed_db/indexed_db_context_impl.cc
文件路径(未找到): src/content/browser/indexed_db/indexed_db_factory_impl.cc
文件路径(未找到): src/content/browser/indexed_db/indexed_db_backing_store.cc
文件路径(未找到): src/content/browser/indexed_db/indexed_db_connection.cc
文件路径(未找到): src/content/browser/indexed_db/indexed_db_transaction.cc
文件路径(未找到): src/third_party/blink/renderer/modules/indexeddb/idb_factory.cc
文件路径(未找到): src/third_party/blink/renderer/modules/indexeddb/idb_database.cc
文件路径(未找到): src/third_party/blink/renderer/modules/indexeddb/idb_request.cc
文件路径(未找到): src/third_party/blink/renderer/modules/indexeddb/web_idb_database_impl.cc
文件路径(未找到): src/storage/browser/quota/quota_manager_impl.cc
文件路径(未找到): src/content/browser/storage_partition_impl.cc
文件路径(未找到): src/content/browser/service_worker/service_worker_storage.cc

// 修改实现细节：
// - IndexedDB 指纹基于网站在客户端存储的数据。
// - 修改的核心在于控制网站对 IndexedDB 数据库的访问和数据存储。
// - 需要修改 src/content/browser/indexed_db/indexed_db_database.cc 等文件中处理 IndexedDB 操作的逻辑。
// - 在存储服务层，例如 src/content/browser/indexed_db/indexed_db_context_impl.cc，负责管理 IndexedDB 数据库的上下文和数据持久化，可能需要在此处进行拦截和修改。
// - 实现"隔离"可以确保不同指纹配置下的 IndexedDB 数据相互独立；实现"禁用"则阻止网站使用 IndexedDB。
//
// - 针对最新指纹检测技术的特定防护措施：
//
//   1. 数据库特征防护：
//      - 在 src/content/browser/indexed_db/indexed_db_factory_impl.cc 中控制数据库创建特征
//      - 修改 src/third_party/blink/renderer/modules/indexeddb/idb_factory.cc 中的JavaScript接口层工厂实现
//      - 确保数据库名称、版本号、对象存储名称等元数据在不同指纹配置下保持一致
//      - 处理数据库升级和架构迁移行为，避免通过版本变化检测用户身份
//      - 标准化数据库结构创建模式，控制对象存储、索引和键路径的创建特征
//
//   2. 存储容量和配额检测防护：
//      - 修改 src/storage/browser/quota/quota_manager_impl.cc 控制存储配额报告
//      - 在 src/content/browser/indexed_db/indexed_db_context_impl.cc 中管理存储使用统计
//      - 确保存储限制与设备特性相符，避免通过异常配额检测设备
//      - 处理存储超限错误的行为一致性，确保错误消息和代码统一
//      - 模拟合理的存储增长模式，避免通过使用模式识别用户
//
//   3. 性能特征防护：
//      - 控制 src/content/browser/indexed_db/indexed_db_transaction.cc 中的事务执行性能
//      - 修改 src/content/browser/indexed_db/indexed_db_backing_store.cc 中的底层存储性能
//      - 标准化数据库操作的响应时间，避免通过性能特征识别设备
//      - 处理大数据量操作的性能表现，确保与设备配置一致
//      - 统一不同类型操作（读/写/删除）的性能特征
//
//   4. 错误处理和异常行为防护：
//      - 修改 src/third_party/blink/renderer/modules/indexeddb/idb_request.cc 中的错误处理逻辑
//      - 统一不同环境下的错误消息和代码，避免通过错误模式识别浏览器
//      - 处理边缘情况下的行为，如存储已满、并发访问冲突等
//      - 确保事务中止和回滚的行为一致性
//      - 控制异步操作的完成顺序和时机
//
//   5. 隐私模式和跨源行为防护：
//      - 增强 src/content/browser/storage_partition_impl.cc 中的存储隔离逻辑
//      - 修改 src/content/browser/service_worker/service_worker_storage.cc 处理后台存储访问
//      - 确保隐私浏览模式下的IndexedDB行为一致性
//      - 处理跨源iframe和Service Worker的IndexedDB访问控制
//      - 统一不同浏览上下文（主框架、iframe、worker）的存储行为
//
// - 检测对抗策略：
//   * 智能存储特征模拟：基于用户配置生成合理的数据库结构和性能特征
//   * 数据库行为一致性：确保所有IndexedDB API的行为逻辑与配置一致
//   * 动态存储策略：支持运行时调整存储模式，适应不同检测场景
//   * 跨上下文同步：统一不同执行上下文的IndexedDB访问行为
//   * 数据库事件控制：确保success、error、upgradeneeded等事件的触发符合预期
//
// - 协同指纹项目：
//   * 与localStorage本地存储（指纹39）协调，确保存储策略一致
//   * 与Cookie指纹协调，统一不同存储机制的隔离策略
//   * 与设备内存指纹协调，确保存储配额与设备配置相符
//   * 与浏览器缓存指纹协调，统一各类存储的清理策略
//   * 与Service Worker指纹协调，处理后台存储访问行为

43、无头模式指纹防护 【开启 关闭】
// 无头模式(Headless)通常被自动化工具使用，但容易被网站识别和检测。
// 注意：无头模式运行时会有多种特征泄露，包括缺少某些插件、硬件信息不符合预期等。
文件路径(已验证): src/headless/lib/browser/headless_browser_impl.cc
文件路径(已验证): src/headless/lib/browser/headless_web_contents_impl.cc
文件路径(已验证): src/headless/public/headless_browser.h
文件路径(已验证): src/third_party/blink/renderer/core/frame/navigator.cc
文件路径(已验证): src/content/common/user_agent.cc
文件路径(已验证): src/content/browser/devtools/devtools_agent_host_impl.cc
文件路径(已验证): src/gpu/command_buffer/client/gles2_implementation.cc
文件路径(已验证): src/ui/display/screen.cc
文件路径(已验证): src/content/browser/devtools/protocol/target_handler.cc
文件路径(已验证): src/headless/lib/browser/headless_content_browser_client.cc

// 修改实现细节：
// - 无头模式指纹主要通过多个特征组合检测，而非单一指标，因此需要全面修改。
// - 主要修改点包括：
//   1. navigator.webdriver属性：在 src/third_party/blink/renderer/core/frame/navigator.cc 中修改 navigator.webdriver 属性的返回值，强制返回 false。
//      这是检测无头模式最常用的特征之一，几乎所有指纹检测库都会先检查此属性。
//   2. User-Agent字符串：修改 src/content/common/user_agent.cc 中的 UA 生成逻辑，删除或隐藏 "Headless" 标识。
//      典型的无头模式 User-Agent 包含 "HeadlessChrome" 字样，需要替换为普通的 "Chrome" 字符串。
//   3. 窗口尺寸和屏幕属性：在 src/headless/lib/browser/headless_web_contents_impl.cc 和 src/ui/display/screen.cc 中
//      伪造符合正常浏览器的窗口尺寸、视口尺寸和屏幕分辨率，避免出现如 0x0 或异常小的尺寸值。
//      还需要模拟 window.outerHeight 和 window.outerWidth 与正常浏览器一致的差值关系。
//   4. 插件和媒体设备：在 navigator.cc 中伪造插件列表和媒体设备列表，避免返回空列表。
//      修改 navigator.plugins 和 navigator.mimeTypes 以返回非空对象，在媒体设备列表中添加音频和视频设备。
//   5. 浏览器特性检测：修改 src/headless/lib/browser/headless_content_browser_client.cc 中的实现，
//      补充无头模式下缺失的特定浏览器功能，如权限请求、通知API、浏览器语言设置等。
//   6. WebGL/Canvas指纹：在 src/gpu/command_buffer/client/gles2_implementation.cc 中调整WebGL参数和行为，
//      修改 WebGL 渲染器和供应商字符串，补充支持的扩展，使其与普通浏览器一致。
//   7. 隐藏DevTools协议痕迹：在 src/content/browser/devtools/devtools_agent_host_impl.cc 和
//      src/content/browser/devtools/protocol/target_handler.cc 中修改自动化检测相关的接口，
//      避免暴露远程调试相关的信息和方法。
//   8. 硬件加速与性能特征：模拟正常浏览器的硬件加速行为和性能特征，包括动画帧率和计时精度，
//      避免通过性能异常来检测无头模式。
//   9. 弹出窗口和打印对话框：确保 window.print() 和 window.alert() 等方法表现正常，
//      避免在无头模式下这些方法的行为异常而被检测。
//   10.字体和渲染：修改 src/headless/lib/browser/headless_browser_impl.cc 中的字体渲染选项，
//      确保系统字体正常加载，避免出现特定字体缺失的情况。
// - 这些修改应该统一协调，确保各种指纹特征保持一致，避免出现矛盾或异常的行为特征。
// - 通过这些修改，无头模式浏览器可以伪装成正常浏览器，避免被自动化检测工具识别。
